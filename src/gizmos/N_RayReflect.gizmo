Gizmo {
 inputs 4
 addUserKnob {20 User l "N Ray Reflect"}
 addUserKnob {41 in l Normals t "The channels that contain the normal data." T Shuffle1.in}
 addUserKnob {26 ""}
 addUserKnob {3 ray_samples l "Ray Samples" t "The number of ray samples. If you are not using roughness or diffuse surfaces, set this to 1."}
 ray_samples 1
 addUserKnob {7 incident_refractive_index l "Incident Refractive Index" t "The index of refraction of the medium before refraction." R 1 3}
 incident_refractive_index 1
 addUserKnob {7 refracted_refractive_index l "Refracted Refractive Index" t "The index of refraction of the medium after refraction." R 1 3}
 refracted_refractive_index 1.33
 addUserKnob {26 ""}
 addUserKnob {7 hdri_offset l "HDRI Offset Angle" t "Rotate the HDRI by this angle." R 0 360}
 addUserKnob {26 ""}
 addUserKnob {26 INFO l "" +STARTLINE T "v1.0 - (c) Owen Bulka and Riley Gray - 2022 "}
}
 BackdropNode {
  inputs 0
  name info
  label "surface is:\nR: Specular\nG: Specular Roughness\nB: Transmission\nA: Transmission Roughness"
  xpos 793
  ypos -12
  bdwidth 156
  bdheight 127
 }
 Input {
  inputs 0
  name camera
  xpos 142
  ypos 302
  number 2
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos 152
  ypos 378
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
 Constant {
  inputs 0
  name Constant4
  xpos 980
  ypos 52
 }
 Reformat {
  type "to box"
  box_width {{parent.normals_dot.width}}
  box_height {{parent.normals_dot.height}}
  box_fixed true
  name Reformat3
  xpos 980
  ypos 124
 }
set Na4b7cc0 [stack 0]
 Dot {
  name Dot2
  xpos 930
  ypos 128
 }
set Nad72dc0 [stack 0]
 Dot {
  name Dot4
  xpos 763
  ypos 128
 }
set Na331cf0 [stack 0]
 Dot {
  name Dot3
  xpos 593
  ypos 128
 }
 Input {
  inputs 0
  name normals
  xpos 480
  ypos 80
 }
 Merge2 {
  inputs 2
  name merge1
  xpos 480
  ypos 163
 }
 Shuffle {
  in rgb
  name Shuffle1
  xpos 480
  ypos 189
 }
 Dot {
  name normals_dot
  xpos 514
  ypos 286
 }
set Na2b8930 [stack 0]
 Dot {
  name Dot5
  xpos 414
  ypos 286
 }
 Dot {
  name Dot7
  xpos 414
  ypos 494
 }
push $Na331cf0
 Input {
  inputs 0
  name hdri
  xpos 647
  ypos 80
  number 1
 }
 Merge2 {
  inputs 2
  bbox B
  name merge2
  xpos 647
  ypos 168
 }
 Dot {
  name Dot1
  xpos 681
  ypos 279
 }
push $Nad72dc0
 Input {
  inputs 0
  name surface
  xpos 813
  ypos 77
  number 3
 }
 Merge2 {
  inputs 2
  bbox B
  name merge
  xpos 813
  ypos 169
 }
 Dot {
  name Dot6
  xpos 847
  ypos 279
 }
push $Na4b7cc0
 Noise {
  output {rgba.red -rgba.green -rgba.blue -rgba.alpha}
  size 1
  zoffset 2.1
  center {1024 778}
  name Noise4
  xpos 980
  ypos 195
 }
 Noise {
  output {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  size 1
  zoffset 0.92
  lacunarity 4.2
  gain 0.685
  center {1024 778}
  name Noise3
  xpos 980
  ypos 221
 }
 Noise {
  output {-rgba.red -rgba.green rgba.blue -rgba.alpha}
  size 1
  zoffset 4.04
  lacunarity 3.28
  gain 0.328
  center {1024 778}
  name Noise2
  xpos 980
  ypos 247
 }
 Noise {
  output {-rgba.red -rgba.green -rgba.blue rgba.alpha}
  size 1
  zoffset 4.74
  lacunarity 1.59
  center {1024 778}
  name Noise1
  xpos 980
  ypos 273
 }
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/normal_ray_reflect/src/blink/kernels/random.blink
  recompileCount 2
  KernelDescription "2 \"Random\" iterate pixelWise 8e779966f94c894fa6f109f51d3914f34c4f7ba1db7b9984184abc7f04f54c4a 2 \"seed\" Read Point \"dst\" Write Point 1 \"Inclusive Range\" Float 2 AAAAAAAAgD8= 1 \"_inclusiveRange\" 2 1 1 \"__rangeLength\" Float 1 1 AAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(seed * 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float4 random(const float4 &seed)\n\{\n    return float4(\n        random(seed.x),\n        random(seed.y),\n        random(seed.z),\n        random(seed.w)\n    );\n\}\n\n\nkernel Random : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeNone> seed; // the input image\n    Image<eWrite> dst; // the output image\n\n\n    param:\n        float2 _inclusiveRange;\n\n    local:\n        float __rangeLength;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_inclusiveRange, \"Inclusive Range\", float2(0, 1));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __rangeLength = _inclusiveRange.y - _inclusiveRange.x;\n    \}\n\n\n    /**\n     * Compute a random pixel value.\n     */\n    void process()\n    \{\n        dst() = __rangeLength * random(seed()) + _inclusiveRange.x;\n    \}\n\};\n"
  rebuild ""
  rebuild_finalise ""
  name BlinkScript1
  xpos 980
  ypos 318
 }
 Dot {
  name Dot8
  xpos 1014
  ypos 402
 }
push $Na2b8930
 BlinkScript {
  inputs 4
  kernelSourceFile /home/ob1/software/nuke/dev/normal_ray_reflect/src/blink/kernels/normal_ray_reflect.blink
  recompileCount 133
  ProgramGroup 1
  KernelDescription "2 \"NormalReflectionKernel\" iterate pixelWise 7ffe4869d0b0b9792ef80c7bbcd0600cf9be5e4c1ec3614f461fe0a21dcfc4aa 5 \"normals\" Read Point \"seeds\" Read Point \"surface\" Read Point \"hdri\" Read Random \"dst\" Write Point 11 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"HDRI Offset Angle\" Float 1 AAAAAA== \"Samples\" Int 1 AQAAAA== \"Incident Refractive Index\" Float 1 AACAPw== \"Refracted Refractive Index\" Float 1 cT2qPw== 11 \"_focalLength\" 1 1 \"_horizontalAperture\" 1 1 \"_nearPlane\" 1 1 \"_farPlane\" 1 1 \"_cameraWorldMatrix\" 16 1 \"_formatWidth\" 1 1 \"_formatHeight\" 1 1 \"_hdriOffsetAngle\" 1 1 \"_samples\" 1 1 \"_incidentRefractiveIndex\" 1 1 \"_refractedRefractiveIndex\" 1 1 4 \"__inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__aperture\" Float 1 1 AAAAAA== \"__hdriPixelSize\" Float 2 1 AAAAAAAAAAA= \"__hdriOffsetRadians\" Float 1 1 AAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n//\n// BlinkScript Normal Reflections\n//\n\n\n//\n// Math\n//\n\n\n/**\n * Blend linearly between two values.\n *\n * @arg value0: The first value.\n * @arg value1: The second value.\n * @arg weight: The blend weight, 1 will return value0, and 0 will\n *     return value1.\n *\n * @returns: The blended value.\n */\ninline float blend(const float value0, const float value1, const float weight)\n\{\n    return value1 + weight * (value0 - value1);\n\}\n\n\n/**\n * Blend linearly between two values.\n *\n * @arg value0: The first value.\n * @arg value1: The second value.\n * @arg weight: The blend weight, 1 will return value0, and 0 will\n *     return value1.\n *\n * @returns: The blended value.\n */\ninline float3 blend(const float3 &value0, const float3 &value1, const float weight)\n\{\n    return value1 + weight * (value0 - value1);\n\}\n\n\n/**\n * Get the equivalent theta and phi values that lie between \[0, 2 * PI),\n * and \[0, PI) respectively.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent theta and phi.\n */\ninline float2 normalizeAngles(const float2 &angles)\n\{\n    float2 normalizedAngles = float2(\n        fmod(angles.x, 2.0f * PI),\n        fmod(angles.y, PI)\n    );\n    normalizedAngles.x += 2 * PI * (normalizedAngles.x < 0);\n    normalizedAngles.y += PI * (normalizedAngles.y < 0);\n\n    return normalizedAngles;\n\}\n\n\n/**\n * Convert a cartesion unit vector to spherical.\n *\n * @arg rayDirection: The cartesion unit vector.\n * @arg thetaOffset: Offset the theta angle by this amount.\n *\n * @returns: The spherical angles in radians.\n */\ninline float2 cartesionUnitVectorToSpherical(\n        const float3 &rayDirection,\n        const float thetaOffset)\n\{\n    return normalizeAngles(float2(\n        atan2(rayDirection.z, rayDirection.x) + thetaOffset,\n        acos(rayDirection.y)\n    ));\n\}\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n\{\n    position = float3(\n        worldMatrix\[0]\[3],\n        worldMatrix\[1]\[3],\n        worldMatrix\[2]\[3]\n    );\n\}\n\n\n/**\n * Saturate a value ie. clamp between 0 and 1\n *\n * @arg value: The value to saturate\n *\n * @returns: The clamped value\n */\ninline float saturate(float value)\n\{\n    return clamp(value, 0.0f, 1.0f);\n\}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n\{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n\}\n\n\n/**\n * Compute the aspect ratio from image format.\n *\n * @arg height_: The height of the image.\n * @arg width_: The width of the image.\n *\n * @returns: The aspect ratio.\n */\ninline float aspectRatio(const float height_, const float width_)\n\{\n    return height_ / width_;\n\}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n\{\n    return float3(\n        m\[0]\[0] * v.x + m\[0]\[1] * v.y + m\[0]\[2] * v.z,\n        m\[1]\[0] * v.x + m\[1]\[1] * v.y + m\[1]\[2] * v.z,\n        m\[2]\[0] * v.x + m\[2]\[1] * v.y + m\[2]\[2] * v.z\n    );\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n\{\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n\{\n    float4 out;\n    matmul(m, v, out);\n    return out;\n\}\n\n\n/**\n * Convert degrees to radians.\n *\n * @arg angle: The angle in degrees.\n *\n * @returns: The angle in radians.\n */\ninline float degreesToRadians(const float angle)\n\{\n    return angle * PI / 180.0f;\n\}\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * The positive part of the vector. Ie. any negative values will be 0.\n *\n * @arg vector: The vector.\n *\n * @returns: The positive part of the vector.\n */\ninline float positivePart(const float value)\n\{\n    return max(value, 0.0f);\n\}\n\n\n/**\n * Get a rotation matrix from an axis and an angle about that axis.\n *\n * @arg angles: The rotation angles in radians.\n * @arg out: The location to store the rotation matrix.\n */\ninline void axisAngleRotationMatrix(const float3 &axis, const float angle, float3x3 &out)\n\{\n    const float cosAngle = cos(angle);\n    const float oneMinusCosAngle = 1.0f - cosAngle;\n    const float sinAngle = sin(angle);\n\n    const float3 axisSquared = axis * axis;\n\n    const float axisXY = axis.x * axis.y * oneMinusCosAngle;\n    const float axisXZ = axis.x * axis.z * oneMinusCosAngle;\n    const float axisYZ = axis.y * axis.z * oneMinusCosAngle;\n\n    const float3 axisSinAngle = axis * sinAngle;\n\n    out\[0]\[0] = cosAngle + axisSquared.x * oneMinusCosAngle;\n    out\[0]\[1] = axisXY - axisSinAngle.z;\n    out\[0]\[2] = axisXZ + axisSinAngle.y;\n    out\[1]\[0] = axisXY + axisSinAngle.z;\n    out\[1]\[1] = cosAngle + axisSquared.y * oneMinusCosAngle;\n    out\[1]\[2] = axisYZ - axisSinAngle.x;\n    out\[2]\[0] = axisXZ - axisSinAngle.y;\n    out\[2]\[1] = axisYZ + axisSinAngle.x;\n    out\[2]\[2] = cosAngle + axisSquared.z * oneMinusCosAngle;\n\}\n\n\n/**\n * Get the angle and axis to use to rotate a vector onto another.\n *\n * @arg axis: The rotation angles in radians.\n * @arg out: The location to store the axis.\n *\n * @returns: The angle.\n */\ninline float getAngleAndAxisBetweenVectors(\n        const float3 &vector0,\n        const float3 &vector1,\n        float3 &axis)\n\{\n    const float3 perpendicularVector = cross(vector0, vector1);\n    if (length(perpendicularVector) > 0.0f)\n    \{\n        axis = normalize(perpendicularVector);\n    \}\n    else if (vector1.z != 0.0f || vector1.y != 0.0f)\n    \{\n        axis = normalize(cross(float3(1, 0, 0), vector1));\n    \}\n    else if (vector1.x != 0.0f || vector1.z != 0.0f)\n    \{\n        axis = normalize(cross(float3(0, 1, 0), vector1));\n    \}\n    else if (vector1.x != 0.0f || vector1.y != 0.0f)\n    \{\n        axis = normalize(cross(float3(0, 0, 1), vector1));\n    \}\n    else\n    \{\n        axis = vector0;\n    \}\n    return acos(dot(vector0, vector1));\n\}\n\n\n/**\n * Align a vector that has been defined relative to an axis with another\n * axis. For example if a vector has been chosen randomly in a\n * particular hemisphere, rotate that hemisphere to align with a new\n * axis.\n *\n * @arg unalignedAxis: The axis, about which, the vector was defined.\n * @arg alignDirection: The axis to align with.\n * @arg vectorToAlign: The vector that was defined relative to\n *     unalignedAxis.\n *\n * @returns: \n */\ninline float3 alignWithDirection(\n        const float3 &unalignedAxis,\n        const float3 &alignDirection,\n        const float3 &vectorToAlign)\n\{\n    float3 rotationAxis;\n    const float angle = getAngleAndAxisBetweenVectors(\n        unalignedAxis,\n        alignDirection,\n        rotationAxis\n    );\n\n    if (angle == 0.0f)\n    \{\n        return vectorToAlign;\n    \}\n\n    float3x3 rotationMatrix;\n    axisAngleRotationMatrix(rotationAxis, angle, rotationMatrix);\n\n    return matmul(rotationMatrix, vectorToAlign);\n\}\n\n\n//\n// Random\n//\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(seed * 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float2 random(const float2 &seed)\n\{\n    return float2(\n        random(seed.x),\n        random(seed.y)\n    );\n\}\n\n\n/**\n * Create a random unit vector in the hemisphere aligned along the\n * z-axis, with a distribution that is cosine weighted.\n *\n * @arg seed: The random seed.\n *\n * @returns: A random unit vector.\n */\nfloat3 cosineDirectionInZHemisphere(const float2 &seed)\n\{\n    const float uniform = random(seed.x);\n    const float r = sqrt(uniform);\n    const float angle = 2 * PI * random(seed.y);\n \n    const float x = r * cos(angle);\n    const float y = r * sin(angle);\n \n    return float3(x, y, sqrt(positivePart(1 - uniform)));\n\}\n\n\n/**\n * Create a random unit vector in the hemisphere aligned along the\n * given axis, with a distribution that is cosine weighted.\n *\n * @arg axis: The axis to align the hemisphere with.\n * @arg seed: The random seed.\n *\n * @returns: A random unit vector.\n */\nfloat3 cosineDirectionInHemisphere(const float3 &axis, const float2 &seed)\n\{\n    return normalize(alignWithDirection(\n        float3(0, 0, 1),\n        axis,\n        cosineDirectionInZHemisphere(seed)\n    ));\n\}\n\n\n//\n// Camera\n//\n\n\n/**\n * Create a projection matrix for a camera.\n *\n * @arg focalLength: The focal length of the camera.\n * @arg horizontalAperture: The horizontal aperture of the camera.\n * @arg aspect: The aspect ratio of the camera.\n * @arg nearPlane: The distance to the near plane of the camera.\n * @arg farPlane: The distance to the far plane of the camera.\n *\n * @returns: The camera's projection matrix.\n */\nfloat4x4 projectionMatrix(\n        const float focalLength,\n        const float horizontalAperture,\n        const float aspect,\n        const float nearPlane,\n        const float farPlane)\n\{\n    float farMinusNear = farPlane - nearPlane;\n    return float4x4(\n        2 * focalLength / horizontalAperture, 0, 0, 0,\n        0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n        0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n        0, 0, -1, 0\n    );\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    float4 direction = matmul(\n        inverseProjectionMatrix,\n        float4(uvPosition.x, uvPosition.y, 0, 1)\n    );\n    matmul(\n        cameraWorldMatrix,\n        float4(direction.x, direction.y, direction.z, 0),\n        direction\n    );\n    rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n\}\n\n\n//\n// Surface Interaction\n//\n\n\n/**\n * Reflect a ray off of a surface.\n *\n * @arg incidentRayDirection: The incident direction.\n * @arg surfaceNormalDirection: The normal to the surface.\n */\ninline float3 reflectRayOffSurface(\n        const float3 &incidentRayDirection,\n        const float3 &surfaceNormalDirection)\n\{\n    return normalize(\n        incidentRayDirection\n        - 2 * dot(incidentRayDirection, surfaceNormalDirection) * surfaceNormalDirection\n    );\n\}\n\n\n/**\n * Refract a ray through a surface.\n *\n * @arg incidentRayDirection: The incident direction.\n * @arg surfaceNormalDirection: The normal to the surface.\n * @arg incidentRefractiveIndex: The refractive index the incident ray\n *     is travelling through.\n * @arg refractedRefractiveIndex: The refractive index the refracted ray\n *     will be travelling through.\n *\n * @returns: The refracted ray direction.\n */\ninline float3 refractRayThroughSurface(\n        const float3 &incidentRayDirection,\n        const float3 &surfaceNormalDirection,\n        const float incidentRefractiveIndex,\n        const float refractedRefractiveIndex)\n\{\n    const float refractiveRatio = incidentRefractiveIndex / refractedRefractiveIndex;\n    const float cosIncident = -dot(incidentRayDirection, surfaceNormalDirection);\n    const float sinTransmittedSquared = refractiveRatio * refractiveRatio * (\n        1.0f - cosIncident * cosIncident\n    );\n    if (sinTransmittedSquared > 1.0f)\n    \{\n        return reflectRayOffSurface(incidentRayDirection, surfaceNormalDirection);\n    \}\n    const float cosTransmitted = sqrt(1.0f - sinTransmittedSquared);\n    return normalize(\n        refractiveRatio * incidentRayDirection\n        + (refractiveRatio * cosIncident - cosTransmitted) * surfaceNormalDirection\n    );\n\}\n\n\n/**\n * Compute the schlick, simplified fresnel reflection coefficient.\n *\n * @arg incidentRayDirection: The incident direction.\n * @arg surfaceNormalDirection: The normal to the surface.\n * @arg incidentRefractiveIndex: The refractive index the incident ray\n *     is travelling through.\n * @arg refractedRefractiveIndex: The refractive index the refracted ray\n *     will be travelling through.\n *\n * @returns: The reflection coefficient.\n */\nfloat schlickReflectionCoefficient(\n        const float3 &incidentRayDirection,\n        const float3 &surfaceNormalDirection,\n        const float incidentRefractiveIndex,\n        const float refractedRefractiveIndex)\n\{\n    const float parallelCoefficient = pow(\n        (incidentRefractiveIndex - refractedRefractiveIndex)\n        / (incidentRefractiveIndex + refractedRefractiveIndex),\n        2\n    );\n    float cosX = -dot(surfaceNormalDirection, incidentRayDirection);\n    if (incidentRefractiveIndex > refractedRefractiveIndex)\n    \{\n        const float refractiveRatio = incidentRefractiveIndex / refractedRefractiveIndex;\n        const float sinTransmittedSquared = refractiveRatio * refractiveRatio * (\n            1.0f - cosX * cosX\n        );\n        if (sinTransmittedSquared > 1.0f)\n        \{\n            return 1.0f;\n        \}\n        cosX = sqrt(1.0f - sinTransmittedSquared);\n    \}\n    return parallelCoefficient + (1.0f - parallelCoefficient) * pow(1.0f - cosX, 5);\n\}\n\n\nkernel NormalReflectionKernel : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeClamped> normals;\n    Image<eRead, eAccessPoint, eEdgeClamped> seeds;\n    Image<eRead, eAccessPoint, eEdgeClamped> surface;\n\n    // the hdri in latlong format\n    Image<eRead, eAccessRandom, eEdgeClamped> hdri;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float _focalLength;\n        float _horizontalAperture;\n        float _nearPlane;\n        float _farPlane;\n        float4x4 _cameraWorldMatrix;\n\n        // Image params\n        float _formatWidth;\n        float _formatHeight;\n\n        float _hdriOffsetAngle;\n\n        // Ray Params\n        int _samples;\n\n        float _incidentRefractiveIndex;\n        float _refractedRefractiveIndex;\n\n\n    local:\n        // These local variables are not exposed to the user.\n\n        float4x4 __inverseCameraProjectionMatrix;\n        float __aperture;\n\n        float2 __hdriPixelSize;\n        float __hdriOffsetRadians;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        // Camera params\n        defineParam(_focalLength, \"Focal Length\", 50.0f);\n        defineParam(_horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(_nearPlane, \"Near Plane\", 0.1f);\n        defineParam(_farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            _cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n\n        // Image params\n        defineParam(_formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(_formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(_hdriOffsetAngle, \"HDRI Offset Angle\", 0.0f);\n\n        // Ray Params\n        defineParam(_samples, \"Samples\", 1);\n        defineParam(_incidentRefractiveIndex, \"Incident Refractive Index\", 1.0f);\n        defineParam(_refractedRefractiveIndex, \"Refracted Refractive Index\", 1.33f);\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        float aspect = aspectRatio(_formatHeight, _formatWidth);\n        float4x4 cameraProjectionMatrix = projectionMatrix(\n            _focalLength,\n            _horizontalAperture,\n            aspect,\n            _nearPlane,\n            _farPlane\n        );\n        __inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();\n\n        __hdriPixelSize = float2(\n            hdri.bounds.width() / (2 * PI),\n            hdri.bounds.height() / PI\n        );\n        __hdriOffsetRadians = degreesToRadians(_hdriOffsetAngle);\n    \}\n\n\n    /**\n     * Get the value of hdri the ray would hit at infinite distance\n     *\n     * @arg rayDirection: The direction of the ray.\n     *\n     * @returns: The colour of the pixel in the direction of the ray.\n     */\n    float4 readHDRIValue(float3 rayDirection)\n    \{\n        const float2 angles = cartesionUnitVectorToSpherical(rayDirection, __hdriOffsetRadians);\n\n        // Should be able to say image access is eEdgeClamped and not do this\n        // but I see nan pixels sooo... :(\n        const float2 indices = clamp(\n            float2(\n                __hdriPixelSize.x * angles.x,\n                hdri.bounds.height() - (__hdriPixelSize.y * angles.y)\n            ),\n            float2(0),\n            float2(hdri.bounds.width(), hdri.bounds.height()) - 1.0f\n        );\n\n        return bilinear(hdri, indices.x, indices.y);\n    \}\n\n\n    /**\n     * Create a ray out of the camera\n     *\n     * @arg pixelLocation: The x, and y locations of the pixel.\n     * @arg rayOrigin: The location to store the origin of the new ray.\n     * @arg rayDirection: The location to store the direction of the new\n     *     ray.\n     */\n    void getCameraRay(\n            const float2 &seed,\n            const float2 &pixelLocation,\n            float3 &rayOrigin,\n            float3 &rayDirection)\n    \{\n        const float2 uvCoordinates = pixelsToUV(\n            pixelLocation + random(seed),\n            float2(_formatWidth, _formatHeight)\n        );\n\n        createCameraRay(\n            _cameraWorldMatrix,\n            __inverseCameraProjectionMatrix,\n            uvCoordinates,\n            rayOrigin,\n            rayDirection\n        );\n    \}\n\n\n    /**\n     * Compute a raymarched pixel value.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        const float2 pixelLocation = float2(pos.x, pos.y);\n\n        SampleType(seeds) seed4 = seeds();\n        float2 seed0 = float2(seed4.x, seed4.y);\n        float2 seed1 = float2(seed4.z, seed4.w);\n\n        SampleType(normals) normal = normals();\n        const float3 normalDirection = normalize(float3(\n            normal.x,\n            normal.y,\n            normal.z\n        ));\n\n        float specular = surface(0);\n        float specular_roughness = surface(1);\n        float transmission = surface(2);\n        float transmission_roughness = surface(3);\n        specular_roughness *= specular_roughness;\n        transmission_roughness *= transmission_roughness;\n\n        const float diffuse = saturate(1.0f - transmission - specular);\n\n        float4 resultPixel = float4(0);\n\n        for (int sample=1; sample <= _samples; sample++)\n        \{\n            // Generate a ray from the camera\n            float3 rayOrigin;\n            float3 rayDirection;\n            getCameraRay(\n                seed0,\n                pixelLocation,\n                rayOrigin,\n                rayDirection\n            );\n\n            if (normal.w != 0.0f)\n            \{\n                // Get the diffuse direction for the next ray\n                const float3 diffuseDirection = cosineDirectionInHemisphere(\n                    normalDirection,\n                    seed1\n                );\n\n                if (diffuse > 0.0f)\n                \{\n                    resultPixel += diffuse * readHDRIValue(diffuseDirection);\n                \}\n                float fresnelSpecular = specular;\n                if (transmission > 0.0f)\n                \{\n                    const float reflectivity = schlickReflectionCoefficient(\n                        rayDirection,\n                        normalDirection,\n                        _incidentRefractiveIndex,\n                        _refractedRefractiveIndex\n                    );\n\n                    fresnelSpecular = blend(1.0f, specular, reflectivity);\n\n                    resultPixel += transmission * (1.0f - fresnelSpecular) * readHDRIValue(normalize(blend(\n                        diffuseDirection,\n                        refractRayThroughSurface(\n                            rayDirection,\n                            normalDirection,\n                            _incidentRefractiveIndex,\n                            _refractedRefractiveIndex\n                        ),\n                        transmission_roughness\n                    ))) / (1.0f - specular);\n                \}\n                if (fresnelSpecular > 0.0f)\n                \{\n                    resultPixel += fresnelSpecular * readHDRIValue(normalize(blend(\n                        diffuseDirection,\n                        reflectRayOffSurface(rayDirection, normalDirection),\n                        specular_roughness\n                    )));\n                \}\n            \}\n            else\n            \{\n                resultPixel += readHDRIValue(rayDirection);\n            \}\n\n            // Update the seeds in as unbiased a way as we can think of\n            seed0 = random(seed1 + random(seed0));\n            float x = seed0.x;\n            seed0.x = seed0.y;\n            seed0.y = x;\n            seed1 = random(seed0 + random(seed1));\n            x = seed1.x;\n            seed1.x = seed1.y;\n            seed1.y = seed0.x;\n            seed0.x = x;\n        \}\n\n        dst() = resultPixel / (float) _samples;\n    \}\n\};\n"
  rebuild ""
  "NormalReflectionKernel_Focal Length" {{parent.DummyCam.focal}}
  "NormalReflectionKernel_Horizontal Aperture" {{parent.DummyCam.haperture}}
  "NormalReflectionKernel_Near Plane" {{parent.DummyCam.near}}
  "NormalReflectionKernel_Far Plane" {{parent.DummyCam.far}}
  "NormalReflectionKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
    }
  "NormalReflectionKernel_Screen Width" {{proxy?width*proxy_scale:width}}
  "NormalReflectionKernel_Screen Height" {{proxy?height*proxy_scale:height}}
  "NormalReflectionKernel_HDRI Offset Angle" {{parent.hdri_offset}}
  NormalReflectionKernel_Samples {{parent.ray_samples}}
  "NormalReflectionKernel_Incident Refractive Index" {{parent.incident_refractive_index}}
  "NormalReflectionKernel_Refracted Refractive Index" {{parent.refracted_refractive_index}}
  rebuild_finalise ""
  name BlinkScript3
  xpos 480
  ypos 392
 }
 Expression {
  expr0 isnan(r)?0:r
  expr1 isnan(g)?0:g
  expr2 isnan(b)?0:b
  expr3 isnan(a)?0:a
  name no_nans
  xpos 480
  ypos 430
 }
 CopyBBox {
  inputs 2
  name CopyBBox1
  xpos 480
  ypos 490
 }
 Output {
  name Output1
  xpos 480
  ypos 564
 }
end_group
