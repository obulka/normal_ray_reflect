#! /usr/local/Nuke13.2v2/libnuke-13.2.2.so -nx
version 13.2 v2
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="1976" y="188" w="2504" h="1376" maximized="1" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1841" stretch="1"/>
            <splitter orientation="2">
                <split size="783"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="550"/>
                <dock id="" activePageId="DAG.1" focus="true">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                    <page id="DAG.2"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /home/ob1/software/nuke/dev/normal_ray_reflect/examples/test_script.nk
 frame 12
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 workingSpaceLUT linear
 monitorLut sRGB
 monitorOutLUT rec709
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
Camera3 {
 inputs 0
 translate {0 0 6}
 name Camera1
 xpos -190
 ypos -332
}
set N828eed0 [stack 0]
CheckerBoard2 {
 inputs 0
 format "2048 1024 0 0 2048 1024 1 2K_LatLong"
 name CheckerBoard1
 xpos -263
 ypos -127
}
push $N828eed0
sdf_primitive {
 inputs 0
 name sdf_primitive1
 label sphere
 xpos -40
 ypos -402
}
ray_march {
 inputs 2
 name ray_march1
 xpos -40
 ypos -312
 output_type Normal
 format 0
}
Group {
 inputs 3
 name N_RayReflect
 selected true
 xpos -40
 ypos -104
 addUserKnob {20 User}
 addUserKnob {41 in l Normals T Shuffle1.in}
 addUserKnob {26 ""}
 addUserKnob {3 ray_samples l "Ray Samples"}
 addUserKnob {26 ""}
 addUserKnob {7 hdriOffset l "HDRI Offset Angle" R -180 180}
 addUserKnob {4 hdriRes l "HDRI Resolution" M {"8192 x 4096" "4096 x 2048" "2048 x 1024" "1024 x 512"}}
 hdriRes "4096 x 2048"
 addUserKnob {26 ""}
 addUserKnob {3 Samples}
 Samples 7
 addUserKnob {6 samplingEnable l "Sampling Filter Enable" -STARTLINE}
 samplingEnable true
 addUserKnob {6 removeSub l "Remove Sub Frames" -STARTLINE}
 removeSub true
 addUserKnob {7 AA_filterSize l "AA Filter Size" R 0 8}
 AA_filterSize 2
 addUserKnob {7 sampleSize l "Sampling Size" R 0 8}
 sampleSize 1
 addUserKnob {26 ""}
 addUserKnob {26 INFO l "" +STARTLINE T "v1.0 - (c) Owen Bulka and Riley Gray - 2022 "}
}
 BackdropNode {
  inputs 0
  name info
  label "surface is:\nR: Specular\nG: Specular Roughness\nB: Transmission\nA: Transmission Roughness"
  xpos 959
  ypos -204
  bdwidth 156
  bdheight 127
 }
 Input {
  inputs 0
  name Normals
  xpos 480
  ypos -281
 }
 Shuffle {
  in rgb
  name Shuffle1
  xpos 480
  ypos -209
 }
 NoTimeBlur {
  name NoTimeBlur1
  xpos 480
  ypos -162
  disable {{removeSub?1-samplingEnable:1}}
 }
 Dot {
  name Dot2
  xpos 514
  ypos -111
 }
set N87eabe0 [stack 0]
 Dot {
  name Dot3
  xpos 350
  ypos -111
 }
 Expression {
  expr3 "r==0 && g==0 && b==0? 0:1"
  name Expression1
  xpos 316
  ypos -9
 }
 Dot {
  name Dot4
  xpos 350
  ypos 46
 }
push $N87eabe0
 ColorMatrix {
  matrix {
      {{parent.DummyCam.world_matrix.0} {parent.DummyCam.world_matrix.1} {parent.DummyCam.world_matrix.2}}
      {{parent.DummyCam.world_matrix.4} {parent.DummyCam.world_matrix.5} {parent.DummyCam.world_matrix.6}}
      {{parent.DummyCam.world_matrix.8} {parent.DummyCam.world_matrix.9} {parent.DummyCam.world_matrix.10}}
    }
  invert true
  name ColorMatrix3
  xpos 480
  ypos -72
  disable {{1-samplingEnable}}
 }
 Add {
  channels rgb
  value {0 0 {parent.SubAA.subFrameWave*.01*parent.sampleSize} 0}
  name Add1
  xpos 480
  ypos -39
  disable {{1-samplingEnable}}
 }
 ColorMatrix {
  matrix {
      {{parent.DummyCam.world_matrix.0} {parent.DummyCam.world_matrix.1} {parent.DummyCam.world_matrix.2}}
      {{parent.DummyCam.world_matrix.4} {parent.DummyCam.world_matrix.5} {parent.DummyCam.world_matrix.6}}
      {{parent.DummyCam.world_matrix.8} {parent.DummyCam.world_matrix.9} {parent.DummyCam.world_matrix.10}}
    }
  name ColorMatrix4
  xpos 480
  ypos -13
  disable {{1-samplingEnable}}
 }
 Multiply {
  inputs 1+1
  channels rgba
  value 0
  invert_mask true
  name Multiply1
  xpos 480
  ypos 42
  disable {{1-samplingEnable}}
 }
 Transform {
  translate {{parent.SubAA.subFrameWave*2*parent.AA_filterSize} {(parent.SubAA.subFrameWave(frame+0.25)-.125)*2*parent.AA_filterSize}}
  center {1024 778}
  name Transform3
  xpos 480
  ypos 68
  disable {{1-samplingEnable}}
 }
 Reformat {
  type scale
  name Reformat2
  xpos 480
  ypos 94
 }
 Dot {
  name normals_dot
  xpos 514
  ypos 158
 }
set N8faf520 [stack 0]
 Dot {
  name Dot5
  xpos 353
  ypos 158
 }
 Dot {
  name Dot7
  xpos 353
  ypos 494
 }
 Input {
  inputs 0
  name HDRI
  xpos 813
  ypos -115
  number 1
 }
 Reformat {
  type "to box"
  box_width {{hdriRes==0?8096:hdriRes==1?4096:hdriRes==2?2048:1024}}
  box_height {{hdriRes==0?4096:hdriRes==1?2048:hdriRes==2?1024:512}}
  box_fixed true
  name Reformat1
  xpos 813
  ypos -89
 }
 Dot {
  name Dot1
  xpos 847
  ypos 139
 }
 Constant {
  inputs 0
  format "1 1 0 0 1 1 1 1x1"
  name Constant4
  xpos 1146
  ypos -159
 }
 Reformat {
  type "to box"
  box_width {{parent.normals_dot.width}}
  box_height {{parent.normals_dot.height}}
  box_fixed true
  name Reformat3
  xpos 1146
  ypos -65
 }
set N8fe0b70 [stack 0]
 Input {
  inputs 0
  name surface
  xpos 979
  ypos -115
  number 3
 }
 Merge2 {
  inputs 2
  name previous_merge
  xpos 979
  ypos -65
 }
 Dot {
  name Dot6
  xpos 1013
  ypos 241
 }
push $N8fe0b70
 Noise {
  output {rgba.red -rgba.green -rgba.blue -rgba.alpha}
  size 1
  zoffset 2.1
  center {1024 778}
  name Noise4
  xpos 1146
  ypos -39
 }
 Noise {
  output {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  size 1
  zoffset 0.92
  lacunarity 4.2
  gain 0.685
  center {1024 778}
  name Noise3
  xpos 1146
  ypos -13
 }
 Noise {
  output {-rgba.red -rgba.green rgba.blue -rgba.alpha}
  size 1
  zoffset 4.04
  lacunarity 3.28
  gain 0.328
  center {1024 778}
  name Noise2
  xpos 1146
  ypos 13
 }
 Noise {
  output {-rgba.red -rgba.green -rgba.blue rgba.alpha}
  size 1
  zoffset 4.74
  lacunarity 1.59
  center {1024 778}
  name Noise1
  xpos 1146
  ypos 39
 }
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/normal_ray_reflect/src/blink/kernels/random.blink
  recompileCount 2
  KernelDescription "2 \"Random\" iterate pixelWise 8e779966f94c894fa6f109f51d3914f34c4f7ba1db7b9984184abc7f04f54c4a 2 \"seed\" Read Point \"dst\" Write Point 1 \"Inclusive Range\" Float 2 AAAAAAAAgD8= 1 \"_inclusiveRange\" 2 1 1 \"__rangeLength\" Float 1 1 AAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(seed * 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float4 random(const float4 &seed)\n\{\n    return float4(\n        random(seed.x),\n        random(seed.y),\n        random(seed.z),\n        random(seed.w)\n    );\n\}\n\n\nkernel Random : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeNone> seed; // the input image\n    Image<eWrite> dst; // the output image\n\n\n    param:\n        float2 _inclusiveRange;\n\n    local:\n        float __rangeLength;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_inclusiveRange, \"Inclusive Range\", float2(0, 1));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __rangeLength = _inclusiveRange.y - _inclusiveRange.x;\n    \}\n\n\n    /**\n     * Compute a random pixel value.\n     */\n    void process()\n    \{\n        dst() = __rangeLength * random(seed()) + _inclusiveRange.x;\n    \}\n\};\n"
  rebuild ""
  rebuild_finalise ""
  name BlinkScript1
  xpos 1146
  ypos 84
 }
 Dot {
  name Dot8
  xpos 1180
  ypos 402
 }
push $N8faf520
 BlinkScript {
  inputs 4
  kernelSourceFile /home/ob1/software/nuke/dev/normal_ray_reflect/src/blink/kernels/normal_ray_reflect.blink
  recompileCount 24
  ProgramGroup 1
  KernelDescription "2 \"NormalReflectionKernel\" iterate pixelWise 0ad61337953e464cf32630a4d28eeadfb8d44c36c00f1f09490b5862876b01e8 5 \"normals\" Read Point \"seeds\" Read Point \"surface\" Read Point \"hdri\" Read Random \"dst\" Write Point 11 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"HDRI Offset Angle\" Float 1 AAAAAA== \"Samples\" Int 1 AQAAAA== \"Incident Refractive Index\" Float 1 AACAPw== \"Refracted Refractive Index\" Float 1 cT2qPw== 11 \"_focalLength\" 1 1 \"_horizontalAperture\" 1 1 \"_nearPlane\" 1 1 \"_farPlane\" 1 1 \"_cameraWorldMatrix\" 16 1 \"_formatWidth\" 1 1 \"_formatHeight\" 1 1 \"_hdriOffsetAngle\" 1 1 \"_samples\" 1 1 \"_incidentRefractiveIndex\" 1 1 \"_refractedRefractiveIndex\" 1 1 4 \"__inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__aperture\" Float 1 1 AAAAAA== \"__hdriPixelSize\" Float 2 1 AAAAAAAAAAA= \"__hdriOffsetRadians\" Float 1 1 AAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n//\n// BlinkScript Normal Reflections\n//\n\n\n#define RAND_CONST_0 1.571411510193971f\n\n\n//\n// Math\n//\n\n\n/**\n * Blend linearly between two values.\n *\n * @arg value0: The first value.\n * @arg value1: The second value.\n * @arg weight: The blend weight, 1 will return value0, and 0 will\n *     return value1.\n *\n * @returns: The blended value.\n */\ninline float3 blend(const float3 &value0, const float3 &value1, const float weight)\n\{\n    return value1 + weight * (value0 - value1);\n\}\n\n\n/**\n * Get the equivalent theta and phi values that lie between \[0, 2 * PI),\n * and \[0, PI) respectively.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent theta and phi.\n */\ninline float2 normalizeAngles(const float2 &angles)\n\{\n    float2 normalizedAngles = float2(\n        fmod(angles.x, 2.0f * PI),\n        fmod(angles.y, PI)\n    );\n    normalizedAngles.x += 2 * PI * (normalizedAngles.x < 0);\n    normalizedAngles.y += PI * (normalizedAngles.y < 0);\n\n    return normalizedAngles;\n\}\n\n\n/**\n * Convert a cartesion unit vector to spherical.\n *\n * @arg rayDirection: The cartesion unit vector.\n * @arg thetaOffset: Offset the theta angle by this amount.\n *\n * @returns: The spherical angles in radians.\n */\ninline float2 cartesionUnitVectorToSpherical(\n        const float3 &rayDirection,\n        const float thetaOffset)\n\{\n    return normalizeAngles(float2(\n        atan2(rayDirection.z, rayDirection.x) + thetaOffset,\n        acos(rayDirection.y)\n    ));\n\}\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n\{\n    position = float3(\n        worldMatrix\[0]\[3],\n        worldMatrix\[1]\[3],\n        worldMatrix\[2]\[3]\n    );\n\}\n\n\n/**\n * Saturate a value ie. clamp between 0 and 1\n *\n * @arg value: The value to saturate\n *\n * @returns: The clamped value\n */\ninline float saturate(float value)\n\{\n    return clamp(value, 0.0f, 1.0f);\n\}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n\{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n\}\n\n\n/**\n * Compute the field of view from focal length.\n *\n * @arg focalLength: The focal length.\n *\n * @returns: The equivalent field of view.\n */\ninline float fieldOfView(const float focalLength)\n\{\n    return 2 * atan(1 / focalLength);\n\}\n\n\n/**\n * Compute the aspect ratio from image format.\n *\n * @arg height_: The height of the image.\n * @arg width_: The width of the image.\n *\n * @returns: The aspect ratio.\n */\ninline float aspectRatio(const float height_, const float width_)\n\{\n    return height_ / width_;\n\}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n\{\n    return float3(\n        m\[0]\[0] * v.x + m\[0]\[1] * v.y + m\[0]\[2] * v.z,\n        m\[1]\[0] * v.x + m\[1]\[1] * v.y + m\[1]\[2] * v.z,\n        m\[2]\[0] * v.x + m\[2]\[1] * v.y + m\[2]\[2] * v.z\n    );\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n\{\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n\{\n    float4 out;\n    matmul(m, v, out);\n    return out;\n\}\n\n\n/**\n * Get the rotation component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg rotation: The location to store the rotation.\n */\ninline void rotationFromWorldMatrix(const float4x4 &worldMatrix, float3x3 &rotationMatrix)\n\{\n    rotationMatrix\[0]\[0] = worldMatrix\[0]\[0];\n    rotationMatrix\[0]\[1] = worldMatrix\[0]\[1];\n    rotationMatrix\[0]\[2] = worldMatrix\[0]\[2];\n    rotationMatrix\[1]\[0] = worldMatrix\[1]\[0];\n    rotationMatrix\[1]\[1] = worldMatrix\[1]\[1];\n    rotationMatrix\[1]\[2] = worldMatrix\[1]\[2];\n    rotationMatrix\[2]\[0] = worldMatrix\[2]\[0];\n    rotationMatrix\[2]\[1] = worldMatrix\[2]\[1];\n    rotationMatrix\[2]\[2] = worldMatrix\[2]\[2];\n\}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n\{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n\}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n\{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n\}\n\n\n/**\n * Convert degrees to radians.\n *\n * @arg angle: The angle in degrees.\n *\n * @returns: The angle in radians.\n */\ninline float degreesToRadians(const float angle)\n\{\n    return angle * PI / 180.0f;\n\}\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * The positive part of the vector. Ie. any negative values will be 0.\n *\n * @arg vector: The vector.\n *\n * @returns: The positive part of the vector.\n */\ninline float positivePart(const float value)\n\{\n    return max(value, 0.0f);\n\}\n\n\n/**\n * Get a rotation matrix from an axis and an angle about that axis.\n *\n * @arg angles: The rotation angles in radians.\n * @arg out: The location to store the rotation matrix.\n */\ninline void axisAngleRotationMatrix(const float3 &axis, const float angle, float3x3 &out)\n\{\n    const float cosAngle = cos(angle);\n    const float oneMinusCosAngle = 1.0f - cosAngle;\n    const float sinAngle = sin(angle);\n\n    const float3 axisSquared = axis * axis;\n\n    const float axisXY = axis.x * axis.y * oneMinusCosAngle;\n    const float axisXZ = axis.x * axis.z * oneMinusCosAngle;\n    const float axisYZ = axis.y * axis.z * oneMinusCosAngle;\n\n    const float3 axisSinAngle = axis * sinAngle;\n\n    out\[0]\[0] = cosAngle + axisSquared.x * oneMinusCosAngle;\n    out\[0]\[1] = axisXY - axisSinAngle.z;\n    out\[0]\[2] = axisXZ + axisSinAngle.y;\n    out\[1]\[0] = axisXY + axisSinAngle.z;\n    out\[1]\[1] = cosAngle + axisSquared.y * oneMinusCosAngle;\n    out\[1]\[2] = axisYZ - axisSinAngle.x;\n    out\[2]\[0] = axisXZ - axisSinAngle.y;\n    out\[2]\[1] = axisYZ + axisSinAngle.x;\n    out\[2]\[2] = cosAngle + axisSquared.z * oneMinusCosAngle;\n\}\n\n\n/**\n * Get the angle and axis to use to rotate a vector onto another.\n *\n * @arg axis: The rotation angles in radians.\n * @arg out: The location to store the axis.\n *\n * @returns: The angle.\n */\ninline float getAngleAndAxisBetweenVectors(\n        const float3 &vector0,\n        const float3 &vector1,\n        float3 &axis)\n\{\n    const float3 perpendicularVector = cross(vector0, vector1);\n    if (length(perpendicularVector) > 0.0f)\n    \{\n        axis = normalize(perpendicularVector);\n    \}\n    else if (vector1.z != 0.0f || vector1.y != 0.0f)\n    \{\n        axis = normalize(cross(float3(1, 0, 0), vector1));\n    \}\n    else if (vector1.x != 0.0f || vector1.z != 0.0f)\n    \{\n        axis = normalize(cross(float3(0, 1, 0), vector1));\n    \}\n    else if (vector1.x != 0.0f || vector1.y != 0.0f)\n    \{\n        axis = normalize(cross(float3(0, 0, 1), vector1));\n    \}\n    else\n    \{\n        axis = vector0;\n    \}\n    return acos(dot(vector0, vector1));\n\}\n\n\n/**\n * Align a vector that has been defined relative to an axis with another\n * axis. For example if a vector has been chosen randomly in a\n * particular hemisphere, rotate that hemisphere to align with a new\n * axis.\n *\n * @arg unalignedAxis: The axis, about which, the vector was defined.\n * @arg alignDirection: The axis to align with.\n * @arg vectorToAlign: The vector that was defined relative to\n *     unalignedAxis.\n *\n * @returns: \n */\ninline float3 alignWithDirection(\n        const float3 &unalignedAxis,\n        const float3 &alignDirection,\n        const float3 &vectorToAlign)\n\{\n    float3 rotationAxis;\n    const float angle = getAngleAndAxisBetweenVectors(\n        unalignedAxis,\n        alignDirection,\n        rotationAxis\n    );\n\n    if (angle == 0.0f)\n    \{\n        return vectorToAlign;\n    \}\n\n    float3x3 rotationMatrix;\n    axisAngleRotationMatrix(rotationAxis, angle, rotationMatrix);\n\n    return matmul(rotationMatrix, vectorToAlign);\n\}\n\n\n//\n// Random\n//\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(seed * 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float3 random(const float3 &seed)\n\{\n    return float3(\n        random(seed.x),\n        random(seed.y),\n        random(seed.z)\n    );\n\}\n\n\n/**\n * Create a random unit vector in the hemisphere aligned along the\n * z-axis, with a distribution that is cosine weighted.\n *\n * @arg seed: The random seed.\n *\n * @returns: A random unit vector.\n */\nfloat3 cosineDirectionInZHemisphere(const float3 &seed)\n\{\n    const float uniform = random(seed.x);\n    const float r = sqrt(uniform);\n    const float angle = 2 * PI * random(seed.y);\n \n    const float x = r * cos(angle);\n    const float y = r * sin(angle);\n \n    return float3(x, y, sqrt(positivePart(1 - uniform)));\n\}\n\n\n/**\n * Create a random unit vector in the hemisphere aligned along the\n * given axis, with a distribution that is cosine weighted.\n *\n * @arg axis: The axis to align the hemisphere with.\n * @arg seed: The random seed.\n *\n * @returns: A random unit vector.\n */\nfloat3 cosineDirectionInHemisphere(const float3 &axis, const float3 &seed)\n\{\n    return normalize(alignWithDirection(\n        float3(0, 0, 1),\n        axis,\n        cosineDirectionInZHemisphere(seed)\n    ));\n\}\n\n\n//\n// Camera\n//\n\n\n/**\n * Create a projection matrix for a camera.\n *\n * @arg focalLength: The focal length of the camera.\n * @arg horizontalAperture: The horizontal aperture of the camera.\n * @arg aspect: The aspect ratio of the camera.\n * @arg nearPlane: The distance to the near plane of the camera.\n * @arg farPlane: The distance to the far plane of the camera.\n *\n * @returns: The camera's projection matrix.\n */\nfloat4x4 projectionMatrix(\n        const float focalLength,\n        const float horizontalAperture,\n        const float aspect,\n        const float nearPlane,\n        const float farPlane)\n\{\n    float farMinusNear = farPlane - nearPlane;\n    return float4x4(\n        2 * focalLength / horizontalAperture, 0, 0, 0,\n        0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n        0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n        0, 0, -1, 0\n    );\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    float4 direction = matmul(\n        inverseProjectionMatrix,\n        float4(uvPosition.x, uvPosition.y, 0, 1)\n    );\n    matmul(\n        cameraWorldMatrix,\n        float4(direction.x, direction.y, direction.z, 0),\n        direction\n    );\n    rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n\}\n\n\n//\n// Surface Interaction\n//\n\n\n/**\n * Reflect a ray off of a surface.\n *\n * @arg incidentRayDirection: The incident direction.\n * @arg surfaceNormalDirection: The normal to the surface.\n */\ninline float3 reflectRayOffSurface(\n        const float3 &incidentRayDirection,\n        const float3 &surfaceNormalDirection)\n\{\n    return normalize(\n        incidentRayDirection\n        - 2 * dot(incidentRayDirection, surfaceNormalDirection) * surfaceNormalDirection\n    );\n\}\n\n\n/**\n * Refract a ray through a surface.\n *\n * @arg incidentRayDirection: The incident direction.\n * @arg surfaceNormalDirection: The normal to the surface.\n * @arg incidentRefractiveIndex: The refractive index the incident ray\n *     is travelling through.\n * @arg refractedRefractiveIndex: The refractive index the refracted ray\n *     will be travelling through.\n *\n * @returns: The refracted ray direction.\n */\ninline float3 refractRayThroughSurface(\n        const float3 &incidentRayDirection,\n        const float3 &surfaceNormalDirection,\n        const float incidentRefractiveIndex,\n        const float refractedRefractiveIndex)\n\{\n    const float refractiveRatio = incidentRefractiveIndex / refractedRefractiveIndex;\n    const float cosIncident = -dot(incidentRayDirection, surfaceNormalDirection);\n    const float sinTransmittedSquared = refractiveRatio * refractiveRatio * (\n        1.0f - cosIncident * cosIncident\n    );\n    if (sinTransmittedSquared > 1.0f)\n    \{\n        return reflectRayOffSurface(incidentRayDirection, surfaceNormalDirection);\n    \}\n    const float cosTransmitted = sqrt(1.0f - sinTransmittedSquared);\n    return normalize(\n        refractiveRatio * incidentRayDirection\n        + (refractiveRatio * cosIncident - cosTransmitted) * surfaceNormalDirection\n    );\n\}\n\n\n/**\n * Compute the schlick, simplified fresnel reflection coefficient.\n *\n * @arg incidentRayDirection: The incident direction.\n * @arg surfaceNormalDirection: The normal to the surface.\n * @arg incidentRefractiveIndex: The refractive index the incident ray\n *     is travelling through.\n * @arg refractedRefractiveIndex: The refractive index the refracted ray\n *     will be travelling through.\n *\n * @returns: The reflection coefficient.\n */\nfloat schlickReflectionCoefficient(\n        const float3 &incidentRayDirection,\n        const float3 &surfaceNormalDirection,\n        const float incidentRefractiveIndex,\n        const float refractedRefractiveIndex)\n\{\n    const float parallelCoefficient = pow(\n        (incidentRefractiveIndex - refractedRefractiveIndex)\n        / (incidentRefractiveIndex + refractedRefractiveIndex),\n        2\n    );\n    float cosX = -dot(surfaceNormalDirection, incidentRayDirection);\n    if (incidentRefractiveIndex > refractedRefractiveIndex)\n    \{\n        const float refractiveRatio = incidentRefractiveIndex / refractedRefractiveIndex;\n        const float sinTransmittedSquared = refractiveRatio * refractiveRatio * (\n            1.0f - cosX * cosX\n        );\n        if (sinTransmittedSquared > 1.0f)\n        \{\n            return 1.0f;\n        \}\n        cosX = sqrt(1.0f - sinTransmittedSquared);\n    \}\n    return parallelCoefficient + (1.0f - parallelCoefficient) * pow(1.0f - cosX, 5);\n\}\n\n\nkernel NormalReflectionKernel : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeNone> normals;\n    Image<eRead, eAccessPoint, eEdgeNone> seeds;\n    Image<eRead, eAccessPoint, eEdgeNone> surface;\n\n    // the hdri in latlong format\n    Image<eRead, eAccessRandom, eEdgeClamped> hdri;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float _focalLength;\n        float _horizontalAperture;\n        float _nearPlane;\n        float _farPlane;\n        float4x4 _cameraWorldMatrix;\n\n        // Image params\n        float _formatWidth;\n        float _formatHeight;\n\n        float _hdriOffsetAngle;\n\n        // Ray Params\n        int _samples;\n\n        float _incidentRefractiveIndex;\n        float _refractedRefractiveIndex;\n\n\n    local:\n        // These local variables are not exposed to the user.\n\n        float4x4 __inverseCameraProjectionMatrix;\n        float __aperture;\n\n        float2 __hdriPixelSize;\n        float __hdriOffsetRadians;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        // Camera params\n        defineParam(_focalLength, \"Focal Length\", 50.0f);\n        defineParam(_horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(_nearPlane, \"Near Plane\", 0.1f);\n        defineParam(_farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            _cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n\n        // Image params\n        defineParam(_formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(_formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(_hdriOffsetAngle, \"HDRI Offset Angle\", 0.0f);\n\n        // Ray Params\n        defineParam(_samples, \"Samples\", 1);\n        defineParam(_incidentRefractiveIndex, \"Incident Refractive Index\", 1.0f);\n        defineParam(_refractedRefractiveIndex, \"Refracted Refractive Index\", 1.33f);\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        float aspect = aspectRatio(_formatHeight, _formatWidth);\n        float4x4 cameraProjectionMatrix = projectionMatrix(\n            _focalLength,\n            _horizontalAperture,\n            aspect,\n            _nearPlane,\n            _farPlane\n        );\n        __inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();\n\n        __hdriPixelSize = float2(\n            hdri.bounds.width() / (2 * PI),\n            hdri.bounds.height() / PI\n        );\n        __hdriOffsetRadians = degreesToRadians(_hdriOffsetAngle);\n    \}\n\n\n    /**\n     * Get the value of hdri the ray would hit at infinite distance\n     *\n     * @arg rayDirection: The direction of the ray.\n     *\n     * @returns: The colour of the pixel in the direction of the ray.\n     */\n    float4 readHDRIValue(float3 rayDirection)\n    \{\n        const float2 angles = cartesionUnitVectorToSpherical(rayDirection, __hdriOffsetRadians);\n\n        // Should be able to say image access is eEdgeClamped and not do this\n        // but I see nan pixels sooo... :(\n        const float2 indices = clamp(\n            float2(\n                __hdriPixelSize.x * angles.x,\n                hdri.bounds.height() - (__hdriPixelSize.y * angles.y)\n            ),\n            float2(0),\n            float2(hdri.bounds.width(), hdri.bounds.height()) - 1.0f\n        );\n\n        return bilinear(hdri, indices.x, indices.y);\n    \}\n\n\n    /**\n     * Create a ray out of the camera\n     *\n     * @arg pixelLocation: The x, and y locations of the pixel.\n     * @arg rayOrigin: The location to store the origin of the new ray.\n     * @arg rayDirection: The location to store the direction of the new\n     *     ray.\n     */\n    void getCameraRay(\n            const float2 &pixelLocation,\n            float3 &rayOrigin,\n            float3 &rayDirection)\n    \{\n        const float2 uvCoordinates = pixelsToUV(\n            pixelLocation,\n            float2(_formatWidth, _formatHeight)\n        );\n\n        createCameraRay(\n            _cameraWorldMatrix,\n            __inverseCameraProjectionMatrix,\n            uvCoordinates,\n            rayOrigin,\n            rayDirection\n        );\n    \}\n\n\n    /**\n     * Compute a raymarched pixel value.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        const float2 pixelLocation = float2(pos.x, pos.y);\n\n        SampleType(seeds) seed4 = seeds();\n        float3 seed = float3(seed4.x, seed4.y, seed4.z);\n\n        SampleType(normals) normal = normals();\n        const float3 normalDirection = normalize(float3(\n            normal.x,\n            normal.y,\n            normal.z\n        ));\n\n        float specular = surface(0);\n        float specular_roughness = surface(1);\n        float transmission = surface(2);\n        float transmission_roughness = surface(3);\n        specular_roughness *= specular_roughness;\n        transmission_roughness *= transmission_roughness;\n\n        const float diffuse = saturate(1.0f - transmission - specular);\n\n        float4 resultPixel = float4(0);\n\n        for (int sample=0; sample < _samples; sample++)\n        \{\n            // Generate a ray from the camera\n            float3 rayOrigin;\n            float3 rayDirection;\n            getCameraRay(\n                pixelLocation,\n                rayOrigin,\n                rayDirection\n            );\n\n            if (normal.w != 0.0f)\n            \{\n                // Get the diffuse direction for the next ray\n                const float3 diffuseDirection = cosineDirectionInHemisphere(\n                    normalDirection,\n                    seed\n                );\n\n                if (diffuse > 0.0f)\n                \{\n                    resultPixel += diffuse * readHDRIValue(rayDirection);\n                \}\n                // if (transmission > 0.0f)\n                // \{\n                //     const float reflectivity = schlickReflectionCoefficient(\n                //         rayDirection,\n                //         normalDirection,\n                //         _incidentRefractiveIndex,\n                //         _refractedRefractiveIndex\n                //     );\n\n                //     transmission = saturate(transmission * (1 - reflectivity));\n                //     specular = clamp(specular + reflectivity, 0.0f, 1.0f - transmission);\n\n                //     resultPixel += transmission * readHDRIValue(normalize(blend(\n                //         diffuseDirection,\n                //         refractRayThroughSurface(\n                //             rayDirection,\n                //             normalDirection,\n                //             _incidentRefractiveIndex,\n                //             _refractedRefractiveIndex\n                //         ),\n                //         transmission_roughness\n                //     )));\n                // \}\n                // if (specular > 0.0f)\n                // \{\n                //     resultPixel += specular * readHDRIValue(normalize(blend(\n                //         diffuseDirection,\n                //         reflectRayOffSurface(rayDirection, normalDirection),\n                //         specular_roughness\n                //     )));\n                // \}\n            \}\n\n            seed = random(RAND_CONST_0 * seed);\n        \}\n\n        dst() = resultPixel / (float) _samples;\n    \}\n\};\n"
  rebuild ""
  "NormalReflectionKernel_Focal Length" {{"parent.removeSub? parent.DummyCam.focal(rint(frame)):parent.DummyCam.focal"}}
  "NormalReflectionKernel_Horizontal Aperture" {{"parent.removeSub? parent.DummyCam.haperture(rint(frame)):parent.DummyCam.haperture"}}
  "NormalReflectionKernel_Camera World Matrix" {
      {{"parent.removeSub? parent.DummyCam.world_matrix(rint(frame)):parent.DummyCam.world_matrix"} {"parent.removeSub? parent.DummyCam.world_matrix(rint(frame)):parent.DummyCam.world_matrix"} {"parent.removeSub? parent.DummyCam.world_matrix(rint(frame)):parent.DummyCam.world_matrix"} {"parent.removeSub? parent.DummyCam.world_matrix(rint(frame)):parent.DummyCam.world_matrix"}}
      {{"parent.removeSub? parent.DummyCam.world_matrix(rint(frame)):parent.DummyCam.world_matrix"} {"parent.removeSub? parent.DummyCam.world_matrix(rint(frame)):parent.DummyCam.world_matrix"} {"parent.removeSub? parent.DummyCam.world_matrix(rint(frame)):parent.DummyCam.world_matrix"} {"parent.removeSub? parent.DummyCam.world_matrix(rint(frame)):parent.DummyCam.world_matrix"}}
      {{"parent.removeSub? parent.DummyCam.world_matrix(rint(frame)):parent.DummyCam.world_matrix"} {"parent.removeSub? parent.DummyCam.world_matrix(rint(frame)):parent.DummyCam.world_matrix"} {"parent.removeSub? parent.DummyCam.world_matrix(rint(frame)):parent.DummyCam.world_matrix"} {"parent.removeSub? parent.DummyCam.world_matrix(rint(frame)):parent.DummyCam.world_matrix"}}
      {{"parent.removeSub? parent.DummyCam.world_matrix(rint(frame)):parent.DummyCam.world_matrix"} {"parent.removeSub? parent.DummyCam.world_matrix(rint(frame)):parent.DummyCam.world_matrix"} {"parent.removeSub? parent.DummyCam.world_matrix(rint(frame)):parent.DummyCam.world_matrix"} {"parent.removeSub? parent.DummyCam.world_matrix(rint(frame)):parent.DummyCam.world_matrix"}}
    }
  "NormalReflectionKernel_Screen Width" {{proxy?width*proxy_scale:width}}
  "NormalReflectionKernel_Screen Height" {{proxy?height*proxy_scale:height}}
  "NormalReflectionKernel_HDRI Offset Angle" {{parent.hdriOffset}}
  rebuild_finalise ""
  name BlinkScript3
  xpos 480
  ypos 392
 }
 Expression {
  expr0 isnan(r)?0:r
  expr1 isnan(g)?0:g
  expr2 isnan(b)?0:b
  expr3 isnan(a)?0:a
  name dumb
  xpos 480
  ypos 441
 }
 CopyBBox {
  inputs 2
  name CopyBBox1
  xpos 480
  ypos 490
 }
 TimeBlur {
  divisions {{parent.Samples}}
  shutteroffset centred
  shuttercustomoffset 0
  name TimeBlur1
  xpos 480
  ypos 550
  disable {{1-samplingEnable}}
 }
 Output {
  name Output1
  xpos 480
  ypos 629
 }
 Input {
  inputs 0
  name Camera
  xpos 166
  ypos -115
  number 2
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos 176
  ypos 70
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
 NoOp {
  inputs 0
  name SubFrame
  xpos 661
  ypos -150
  addUserKnob {20 User}
  addUserKnob {7 subFrameWave}
  subFrameWave {{"((frame+0.5) % 1)/1 -.5"}}
 }
 NoOp {
  inputs 0
  name SubAA
  xpos 657
  ypos -46
  addUserKnob {20 User}
  addUserKnob {7 subFrameWave}
  subFrameWave {{clamp((asin(sin(2*pi*(frame)/1))/pi+0.5),.25,.75)-.5 i}}
 }
end_group
