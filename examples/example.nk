#! /usr/local/Nuke13.2v2/libnuke-13.2.2.so -nx
version 13.2 v2
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="1976" y="27" w="3784" h="2096" maximized="1" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="3121" stretch="1"/>
            <splitter orientation="2">
                <split size="1205"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="848"/>
                <dock id="" activePageId="DAG.1" focus="true">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /home/ob1/software/nuke/dev/normal_ray_reflect/examples/example.nk
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 workingSpaceLUT linear
 monitorLut sRGB
 monitorOutLUT rec709
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
Axis3 {
 inputs 0
 translate {0 0 6}
 name Axis2
 xpos -228
 ypos -305
}
Camera3 {
 name Camera2
 xpos -228
 ypos -185
}
set N8d998d0 [stack 0]
CheckerBoard2 {
 inputs 0
 name CheckerBoard2
 xpos -18
 ypos -403
}
Sphere {
 name Sphere1
 xpos -18
 ypos -308
}
push 0
add_layer {position position.red position.green position.blue position.alpha}
add_layer {normals normals.red normals.green normals.blue normals.alpha}
ScanlineRender {
 inputs 3
 conservative_shader_sampling false
 motion_vectors_type distance
 output_shader_vectors true
 P_channel position
 N_channel normals
 name ScanlineRender1
 xpos -18
 ypos -165
}
set N8d587c0 [stack 0]
Group {
 name P_Noise_Advanced2
 knobChanged "\nn = nuke.thisNode()\ntype = n\['noisetype'].value()\nblock = n\['Trunc'].getValue()\nVis = \[]\nHide = \[]\nif type in ('fBm', 'turbulent'):\n    Vis.extend(\['octaves', 'lacunarity', 'gain', 'gamma'])\n    Hide.extend(\['rays', 'range', 'invert', 'ringsSeed', 'raysSeed', 'gammaNormalize'])   \nelif type == 'p_rings':\n    Vis.extend(\['ringsSeed', 'gammaNormalize'])\n    Hide.extend(\['rays', 'range', 'invert', 'octaves', 'lacunarity', 'gain', 'gamma', 'raysSeed'])\nelif type == 'p_rays':\n    Vis.extend(\['rays', 'raysSeed', 'gammaNormalize'])\n    Hide.extend(\['range', 'invert', 'octaves', 'lacunarity', 'gain', 'gamma', 'ringsSeed'])\nelif type in ('Euclidian', 'Voronoi', 'Manhattan', 'ChebyShev'):\n    Vis.extend(\['range', 'gammaNormalize'])\n    Hide.extend(\['rays', 'invert', 'octaves', 'lacunarity', 'gain', 'gamma', 'ringsSeed', 'raysSeed'])\nelif type == 'Worley':\n    Vis.extend(\['invert', 'gammaNormalize'])\n    Hide.extend(\['rays', 'range', 'octaves', 'lacunarity', 'gain', 'gamma', 'ringsSeed', 'raysSeed'])\nfor r in Vis: n\[r].setVisible(True)\nfor x in Hide: n\[x].setVisible(False)\n\nif block == True:\n    n\['truncSize'].setVisible(True)\nelse:\n    n\['truncSize'].setVisible(False)\n"
 label "(\[value in])"
 xpos 681
 ypos -119
 addUserKnob {20 User}
 addUserKnob {41 in l "position data" T Shuffle_Input_Channels.in}
 addUserKnob {6 unpremultiply +STARTLINE}
 addUserKnob {6 useAlpha l "ignore outside alpha" -STARTLINE}
 addUserKnob {6 useGPU l "use GPU if available" -STARTLINE}
 useGPU true
 addUserKnob {26 ""}
 addUserKnob {4 noisetype M {fBm turbulent p_rings p_rays Euclidian Voronoi Manhattan Chebyslev Worley "" "" ""}}
 noisetype turbulent
 addUserKnob {6 Trunc l "blocky (trunc)" -STARTLINE}
 addUserKnob {41 Position2d T SampleXY.Position2d}
 addUserKnob {41 rgbSample l center T Sample.rgbSample}
 addUserKnob {6 useCenter -STARTLINE}
 useCenter true
 addUserKnob {26 ""}
 addUserKnob {18 size R 1 100}
 size 3.8
 addUserKnob {6 size_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 size_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 size_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 size_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 seed}
 seed {0 0 0}
 addUserKnob {6 seed_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 seed_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 seed_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 seed_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 seed_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 size_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 truncSize l "blocky size" +HIDDEN R 0 2}
 truncSize 0.5
 addUserKnob {6 truncSize_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 truncSize_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 truncSize_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 ""}
 addUserKnob {7 rays +HIDDEN}
 rays 30
 addUserKnob {7 raysSeed l "rays seed" +HIDDEN R 0 10}
 addUserKnob {7 ringsSeed l "rings seed" +HIDDEN R 0 10}
 addUserKnob {7 range +HIDDEN R 0 6}
 range 1
 addUserKnob {6 invert +HIDDEN +STARTLINE}
 addUserKnob {3 octaves}
 octaves 1
 addUserKnob {7 lacunarity R 1 10}
 lacunarity 1.5
 addUserKnob {7 gain R 0.1 1}
 gain 1
 addUserKnob {7 gamma}
 gamma 0.328
 addUserKnob {7 gammaNormalize l gamma +HIDDEN R 0 2}
 gammaNormalize 1
 addUserKnob {26 ""}
 addUserKnob {26 INFO l "" +STARTLINE T "v1.2 (c) Riley Gray and Owen Bulka 2020\nBased on \"Cell Noise v1.1\" by Matthew Shaw     "}
 addUserKnob {26 c44_version_author l "" +STARTLINE T "<span style=\"color:#666\"><br/><b>C44Kernel v1.0</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2018</span>"}
 addUserKnob {20 Transform}
 addUserKnob {41 rot_order l "rotation order" T Axis1.rot_order}
 addUserKnob {41 translate T Axis1.translate}
 addUserKnob {41 rotate T Axis1.rotate}
 addUserKnob {41 scaling l scale T Axis1.scaling}
 addUserKnob {41 uniform_scale l "uniform scale" T Axis1.uniform_scale}
 addUserKnob {41 skew T Axis1.skew}
 addUserKnob {41 pivot +INVISIBLE T Axis1.pivot}
}
 Input {
  inputs 0
  name img
  xpos 0
  ypos -116
 }
 AddChannels {
  channels alpha
  color 1
  name AddChannels1
  xpos 0
  ypos -64
 }
 Shuffle {
  in position
  alpha blue
  out rgb
  name Shuffle_Input_Channels
  xpos 0
  ypos -18
 }
 Unpremult {
  name Unpremult1
  xpos 0
  ypos 16
  disable {{!parent.unpremultiply i}}
 }
 Dot {
  name Dot2
  xpos 34
  ypos 66
 }
set N911e7b0 [stack 0]
 Dot {
  name Dot4
  xpos -130
  ypos 66
 }
set N9123760 [stack 0]
 Dot {
  name Dot3
  xpos -292
  ypos 66
 }
 Expression {
  channel0 alpha
  expr0 "a == 0 ? 1 :0"
  channel1 none
  channel2 none
  channel3 {none none none -rgba.alpha}
  name Expression1
  xpos -326
  ypos 751
 }
 Axis2 {
  inputs 0
  name Axis1
  xpos 265
  ypos 200
 }
push $N911e7b0
 Add {
  channels rgb
  value {{parent.Sample.rgbSample/-1} {parent.Sample.rgbSample/-1} {parent.Sample.rgbSample/-1} 0}
  name center
  xpos 0
  ypos 141
  disable {{1-parent.useCenter}}
 }
 Group {
  inputs 2
  name C44Kernel
  help "C44Kernel v1.0 by Adrian Pueyo\n\nMultiply the rgb or rgba colors by an arbitrary 4x4 Matrix. Useful for transforming a Position pass.\n\nYou can plug in an Axis or Camera node into the axis input, to also apply its transformations.\n\nadrianpueyo.com, 2017"
  tile_color 0xe88543ff
  xpos 0
  ypos 221
  lock_connections true
  addUserKnob {20 C44Kernel}
  addUserKnob {41 channels T MergeIn.Achannels}
  addUserKnob {41 matrix T Axis1.matrix}
  addUserKnob {6 invert -STARTLINE}
  addUserKnob {6 alpha_masking l "alpha masking" t "Apply only where rgba.alpha>0" +STARTLINE}
  addUserKnob {20 advanced l Advanced n 1}
  advanced 0
  addUserKnob {6 transpose +STARTLINE}
  addUserKnob {6 w_divide +STARTLINE}
  addUserKnob {6 rgba_mode l "apply on Vector4" t "Usually you'll want to apply the matrix on the RGB only, which uses a white alpha. Enable this to use the full Vector4 (RGBA)." +STARTLINE}
  addUserKnob {20 endGroup n -1}
  addUserKnob {26 ""}
  addUserKnob {41 mix T MergeOut.mix}
  addUserKnob {26 version_author l "" t "C44Kernel v1.0\n23 June, 2018" +STARTLINE T "<span style=\"color:#666\"><br/><b>C44Kernel v1.0</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2018</span>"}
  addUserKnob {20 GPU_Settings l "GPU Settings"}
  addUserKnob {41 maxGPUMemory l "Percentage of GPU memory to use" T C44MatrixKernel.maxGPUMemory}
  addUserKnob {41 maxTileLines l "Percentage of image height per tile" T C44MatrixKernel.maxTileLines}
 }
  Input {
   inputs 0
   name Inputaxis
   xpos 133
   ypos -181
   number 1
  }
  Axis2 {
   useMatrix true
   name Axis1
   xpos 143
   ypos -133
  }
  Input {
   inputs 0
   name Inputimg
   xpos -110
   ypos -192
  }
set N9187e70 [stack 0]
  Dot {
   name Dot1
   xpos -76
   ypos -161
  }
set N918d0a0 [stack 0]
  Expression {
   expr3 a>0
   name ExpressionA
   xpos -220
   ypos -164
  }
  Switch {
   which {{!parent.alpha_masking}}
   name SwitchMasking
   xpos -220
   ypos -112
  }
push $N918d0a0
push $N9187e70
  Remove {
   name RemoveAll
   xpos 34
   ypos -196
  }
  Merge2 {
   inputs 2
   operation copy
   Bchannels none
   name MergeIn
   xpos 34
   ypos -164
  }
  Shuffle {
   alpha white
   name ShuffleWhiteA
   xpos 34
   ypos -140
   disable {{parent.rgba_mode}}
  }
  BlinkScript {
   recompileCount 147
   ProgramGroup 1
   KernelDescription "2 \"C44MatrixKernel\" iterate pixelWise 10f1841ce0aee43165aca4445fb9ce0126826eedd71da6339f12b8f8de8e52eb 2 \"src\" Read Point \"dst\" Write Point 4 \"m\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"invert\" Int 1 AAAAAA== \"transpose\" Int 1 AAAAAA== \"w_divide\" Int 1 AAAAAA== 4 \"m\" 16 1 \"invert\" 1 1 \"transpose\" 1 1 \"w_divide\" 1 1 0"
   kernelSource "kernel C44MatrixKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float4x4 m;\n    int invert;\n    int transpose;\n    int w_divide;\n\n  void process(int2 pos) \{\n    SampleType(src) p = src();\n    float4 result = 1.0f;\n    float4x4 mi = m;\n    mi = invert?mi.invert():mi;\n    mi = transpose?mi.transpose():mi;\n    for(int c = 0; c<dst.kComps; c++)\{\n      result\[c] = mi\[c]\[0]*p.x + mi\[c]\[1]*p.y + mi\[c]\[2]*p.z + mi\[c]\[3]*p.w;\n    \}\n    dst() = w_divide?result/result.w:result;\n  \}\n\};\n"
   rebuild ""
   C44MatrixKernel_m {
       {{Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix}}
       {{Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix}}
       {{Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix}}
       {{Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix}}
     }
   C44MatrixKernel_invert {{parent.invert}}
   C44MatrixKernel_transpose {{parent.transpose}}
   C44MatrixKernel_w_divide {{parent.w_divide}}
   rebuild_finalise ""
   name C44MatrixKernel
   xpos 34
   ypos -116
  }
push $N918d0a0
  Merge2 {
   inputs 2+1
   operation copy
   Bchannels {{{parent.MergeIn.Achannels}}}
   output {{{parent.MergeIn.Achannels}}}
   name MergeOut
   xpos -110
   ypos -112
  }
  Output {
   name Output1
   xpos -110
   ypos -88
  }
 end_group
 Add {
  channels rgb
  value {{parent.seed} {parent.seed} {parent.seed} {parent.seed}}
  name Seed
  xpos 0
  ypos 279
 }
 Multiply {
  channels rgb
  value {{10/parent.size} {10/parent.size} {10/parent.size} {10/parent.size}}
  name size
  xpos 0
  ypos 327
 }
 Expression {
  expr0 trunc(r*truncScale.r)/truncScale.r/.95
  expr1 trunc(g*truncScale.g)/truncScale.g/.95
  expr2 trunc(b*truncScale.b)/truncScale.b/.95
  name Trunc
  xpos 0
  ypos 391
  disable {{1-parent.Trunc}}
  addUserKnob {20 User}
  addUserKnob {18 truncScale R 0.1 10}
  truncScale {{1/parent.truncSize} {1/parent.truncSize} {1/parent.truncSize}}
  addUserKnob {6 truncScale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 truncScale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 truncScale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 truncScale_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 }
 Dot {
  name Dot1
  xpos 34
  ypos 469
 }
set N9232990 [stack 0]
 BlinkScript {
  recompileCount 6
  ProgramGroup 1
  KernelDescription "2 \"Worley\" iterate pixelWise cd00b03232e0b755cf1f537751b291ec18e739c23a26daa3a40693e1bd7ed6d8 2 \"position_pass\" Read Point \"dst\" Write Point 1 \"Invert\" Bool 1 AA== 1 \"invert\" 1 1 0"
  kernelSource "// https://aftbit.com/cell-noise-2/\n\n// C++11\n#define rand_multiplier 48271\n#define rand_increment  0\n#define rand_modulus    2147483647\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\n#define OFFSET_BASIS 2166136261\n#define FNV_PRIME 16777619\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\n#define one    393325350\n#define two   1022645910\n#define three 1861739990\n#define four  2700834071\n#define five  3372109335\n#define six   3819626178\n#define seven 4075350088\n#define eight 4203212043\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n\n// Blink Kernel\nkernel Worley : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint> position_pass;\n  Image<eWrite> dst;\n\n  param:\n    bool invert;\n\n  void define()\n  \{\n    defineParam(invert, \"Invert\", false);\n  \}\n\n  void process()\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float distance = 6666.0f;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float4 position = position_pass();\n    float3 input = float3(position.x, position.y, position.z);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              distance = min(distance, dot(input - featurePoint, input - featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    distance = sqrt(distance);\n    if (invert)\n      distance = 1.0f - distance;\n    dst() = distance;\n\n  \}\n\n\};"
  useGPUIfAvailable {{parent.useGPU}}
  rebuild ""
  Worley_Invert {{parent.invert}}
  rebuild_finalise ""
  name WorleyNoise
  xpos 990
  ypos 579
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma2
  xpos 990
  ypos 615
 }
push $N9232990
 BlinkScript {
  recompileCount 5
  ProgramGroup 1
  KernelDescription "2 \"ChebyshevNoise\" iterate pixelWise 0696bc3791972a27cd4c68d2990c354a3c7c98ff58f45dc3e525fa28b235bbf4 2 \"position_pass\" Read Point \"dst\" Write Point 1 \"Range\" Float 1 AABAQA== 1 \"range\" 1 1 2 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA=="
  kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\n#define rand_multiplier 48271\n#define rand_increment  0\n#define rand_modulus    2147483647\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\n#define OFFSET_BASIS 2166136261\n#define FNV_PRIME 16777619\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\n#define one    393325350\n#define two   1022645910\n#define three 1861739990\n#define four  2700834071\n#define five  3372109335\n#define six   3819626178\n#define seven 4075350088\n#define eight 4203212043\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ChebyshevNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint> position_pass;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n\n  local:\n    float fRange;\n    int iRange;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n  \}\n\n  void process()\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 position = position_pass();\n    float3 input = float3(position.x, position.y, position.z);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ChebyshevDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    dst() = color;\n\n  \}\n\n\};"
  useGPUIfAvailable {{parent.useGPU}}
  rebuild ""
  ChebyshevNoise_Range {{parent.range}}
  format {{{WorleyNoise.format}}}
  rebuild_finalise ""
  name ChebyShevNoise
  xpos 880
  ypos 578
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma3
  xpos 880
  ypos 614
 }
push $N9232990
 BlinkScript {
  recompileCount 16
  ProgramGroup 1
  KernelDescription "2 \"ManhattanNoise\" iterate pixelWise fdbb8a014c9cd7c179e23ccd0729d0213a232c394b85e9bf56c91c66207ca1d2 2 \"position_pass\" Read Point \"dst\" Write Point 1 \"Range\" Float 1 AABAQA== 1 \"range\" 1 1 2 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA=="
  kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\n#define rand_multiplier 48271\n#define rand_increment  0\n#define rand_modulus    2147483647\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\n#define OFFSET_BASIS 2166136261\n#define FNV_PRIME 16777619\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\n#define one    393325350\n#define two   1022645910\n#define three 1861739990\n#define four  2700834071\n#define five  3372109335\n#define six   3819626178\n#define seven 4075350088\n#define eight 4203212043\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n// Blink Kernel\nkernel ManhattanNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint> position_pass;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n\n  local:\n    float fRange;\n    int iRange;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n  \}\n\n  void process()\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 position = position_pass();\n    float3 input = float3(position.x, position.y, position.z);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ManhattanDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    dst() = color;\n\n  \}\n\n\};"
  useGPUIfAvailable {{parent.useGPU}}
  rebuild ""
  ManhattanNoise_Range {{parent.range}}
  format {{{WorleyNoise.format}}}
  rebuild_finalise ""
  name ManhattanNoise
  xpos 770
  ypos 577
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma4
  xpos 770
  ypos 615
 }
push $N9232990
 BlinkScript {
  recompileCount 16
  KernelDescription "2 \"VoronoiNoise\" iterate pixelWise b5254626cd5df5ff862ca8817e176a1b623927081c48080950344a31c6d0cf9e 2 \"position_pass\" Read Point \"dst\" Write Point 1 \"Range\" Float 1 AABAQA== 1 \"range\" 1 1 2 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA=="
  kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\n#define rand_multiplier 48271\n#define rand_increment  0\n#define rand_modulus    2147483647\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\n#define OFFSET_BASIS 2166136261\n#define FNV_PRIME 16777619\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\n#define one    393325350\n#define two   1022645910\n#define three 1861739990\n#define four  2700834071\n#define five  3372109335\n#define six   3819626178\n#define seven 4075350088\n#define eight 4203212043\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], int idArr\[], float value, int id)\n\{\n  float temp;\n  int tempID;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    tempID = idArr\[i];\n    arr\[i] = value;\n    idArr\[i] = id;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n      idArr\[i + 1] = tempID;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel VoronoiNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint> position_pass;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    \n  local:\n    float fRange;\n    int iRange;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n  \}\n\n  void process()\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n    int idArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 position = position_pass();\n    float3 input = float3(position.x, position.y, position.z);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            id = lastRandom;\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, idArray, length(input - featurePoint), id+l);\n            \}\n        \}\n      \}\n    \}\n\n    float3 col = float3(float(idArray\[iRange]) / rand_modulus, 0.0f, 0.0f);\n    lastRandom = lcgRandom(idArray\[iRange]);\n    col.y = float(lastRandom) / rand_modulus;\n    lastRandom = lcgRandom(lastRandom);\n    col.z = float(lastRandom) / rand_modulus;\n\n    for(int component = 0; component < 3; component++)\n      dst(component) = col\[component];\n    dst(3) = 1.0f;\n  \}\n\n\};"
  useGPUIfAvailable {{parent.useGPU}}
  rebuild ""
  VoronoiNoise_Range {{parent.range}}
  format {{{WorleyNoise.format}}}
  rebuild_finalise ""
  name VoronoiNoise
  xpos 658
  ypos 579
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma5
  xpos 658
  ypos 615
 }
push $N9232990
 BlinkScript {
  recompileCount 18
  KernelDescription "2 \"EuclidianNoise\" iterate pixelWise dbf5e83c1b46011f2fc8e7b81e879b31ef00feccf8756cfeccd2d9e033e58784 2 \"position_pass\" Read Point \"dst\" Write Point 1 \"Range\" Float 1 AABAQA== 1 \"range\" 1 1 2 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA=="
  kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\n#define rand_multiplier 48271\n#define rand_increment  0\n#define rand_modulus    2147483647\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\n#define OFFSET_BASIS 2166136261\n#define FNV_PRIME 16777619\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\n#define one    393325350\n#define two   1022645910\n#define three 1861739990\n#define four  2700834071\n#define five  3372109335\n#define six   3819626178\n#define seven 4075350088\n#define eight 4203212043\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel EuclidianNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint> position_pass;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n\n  local:\n    float fRange;\n    int iRange;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n  \}\n\n  void process()\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 position = position_pass();\n    float3 input = float3(position.x, position.y, position.z);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, EuclidianDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    dst() = color;\n\n  \}\n\n\};"
  useGPUIfAvailable {{parent.useGPU}}
  rebuild ""
  EuclidianNoise_Range {{parent.range}}
  format {{{WorleyNoise.format}}}
  rebuild_finalise ""
  name EuclidianNoise
  selected true
  xpos 550
  ypos 572
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma6
  xpos 550
  ypos 615
 }
push $N9232990
 Expression {
  channel0 rgba
  expr0 "sin( atan(r, g) *this.rays+this.rays_seed)"
  channel1 none
  channel2 none
  name rays
  xpos 400
  ypos 582
  addUserKnob {20 User}
  addUserKnob {7 rays}
  rays {{parent.rays}}
  addUserKnob {7 rays_seed l "rays seed"}
  rays_seed {{parent.raysSeed}}
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma7
  xpos 400
  ypos 606
 }
push $N9232990
 Expression {
  channel0 rgba
  expr0 "sin(sqrt( r*r + g*g + b*b)+this.rings_seed)"
  channel1 none
  channel2 none
  name rings
  xpos 259
  ypos 581
  addUserKnob {20 User}
  addUserKnob {7 rings_seed l "rings seed"}
  rings_seed {{parent.ringsSeed}}
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma8
  xpos 259
  ypos 605
 }
push $N9232990
 Expression {
  channel0 rgba
  expr0 "pow(turbulence (r, g, b, this.octaves, this.lacunarity, this.gain), 1/this.gamma)"
  channel1 none
  channel2 none
  channel3 {none none none -rgba.alpha}
  name Turb
  xpos 128
  ypos 578
  addUserKnob {20 User}
  addUserKnob {3 octaves}
  octaves {{parent.octaves}}
  addUserKnob {7 lacunarity R 1 10}
  lacunarity {{parent.lacunarity}}
  addUserKnob {7 gain R 0.1 1}
  gain {{parent.gain}}
  addUserKnob {7 gamma}
  gamma {{parent.gamma}}
 }
push $N9232990
 Expression {
  channel0 rgba
  expr0 "pow((fBm (r, g, b, this.octaves, this.lacunarity, this.gain) +1)/2, 1/this.gamma)"
  channel1 none
  channel2 none
  channel3 {none none none -rgba.alpha}
  name FBM
  xpos 0
  ypos 577
  addUserKnob {20 User}
  addUserKnob {3 octaves}
  octaves {{parent.octaves}}
  addUserKnob {7 lacunarity R 1 10}
  lacunarity {{parent.lacunarity}}
  addUserKnob {7 gain R 0.1 1}
  gain {{parent.gain}}
  addUserKnob {7 gamma}
  gamma {{parent.gamma}}
 }
 Switch {
  inputs 9
  which {{noisetype}}
  name Type
  xpos 0
  ypos 692
 }
 Multiply {
  inputs 1+1
  channels rgba
  value 0
  name Multiply1
  xpos 0
  ypos 751
  disable {{1-parent.useAlpha}}
 }
 Output {
  name Output1
  xpos 0
  ypos 885
 }
push $N9123760
 NoOp {
  name SampleXY
  knobChanged "\nn = nuke.thisNode()\nrgbNode = nuke.toNode('Sample')\nposition = n.knob('Position2d').getValue()\npositionX = position\[0]\npositionY = position\[-1]\nrSample = n.sample(\"r\",positionX,positionY)\ngSample = n.sample(\"g\",positionX,positionY)\nbSample = n.sample(\"b\",positionX,positionY)\nrgbNode.knob('rgbSample').setValue(\[rSample, gSample, bSample])\n"
  xpos -164
  ypos 95
  addUserKnob {20 User}
  addUserKnob {12 Position2d}
  Position2d {914 12}
 }
 NoOp {
  inputs 0
  name Sample
  xpos -162
  ypos 140
  addUserKnob {20 User}
  addUserKnob {18 rgbSample}
  rgbSample {0 0 0}
  addUserKnob {6 rgbSample_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 }
end_group
Grade {
 white 4
 name Grade1
 xpos 681
 ypos -62
}
Dot {
 name Dot4
 xpos 715
 ypos 8
}
set N9365270 [stack 0]
Dot {
 name Dot5
 xpos 715
 ypos 81
}
push $N9365270
Constant {
 inputs 0
 color {1 0.2 0.5 1}
 name Constant2
 xpos 326
 ypos -81
}
push $N8d587c0
Group {
 name P_Noise_Advanced1
 knobChanged "\nn = nuke.thisNode()\ntype = n\['noisetype'].value()\nblock = n\['Trunc'].getValue()\nVis = \[]\nHide = \[]\nif type in ('fBm', 'turbulent'):\n    Vis.extend(\['octaves', 'lacunarity', 'gain', 'gamma'])\n    Hide.extend(\['rays', 'range', 'invert', 'ringsSeed', 'raysSeed', 'gammaNormalize'])   \nelif type == 'p_rings':\n    Vis.extend(\['ringsSeed', 'gammaNormalize'])\n    Hide.extend(\['rays', 'range', 'invert', 'octaves', 'lacunarity', 'gain', 'gamma', 'raysSeed'])\nelif type == 'p_rays':\n    Vis.extend(\['rays', 'raysSeed', 'gammaNormalize'])\n    Hide.extend(\['range', 'invert', 'octaves', 'lacunarity', 'gain', 'gamma', 'ringsSeed'])\nelif type in ('Euclidian', 'Voronoi', 'Manhattan', 'ChebyShev'):\n    Vis.extend(\['range', 'gammaNormalize'])\n    Hide.extend(\['rays', 'invert', 'octaves', 'lacunarity', 'gain', 'gamma', 'ringsSeed', 'raysSeed'])\nelif type == 'Worley':\n    Vis.extend(\['invert', 'gammaNormalize'])\n    Hide.extend(\['rays', 'range', 'octaves', 'lacunarity', 'gain', 'gamma', 'ringsSeed', 'raysSeed'])\nfor r in Vis: n\[r].setVisible(True)\nfor x in Hide: n\[x].setVisible(False)\n\nif block == True:\n    n\['truncSize'].setVisible(True)\nelse:\n    n\['truncSize'].setVisible(False)\n"
 label "(\[value in])"
 xpos 401
 ypos -111
 addUserKnob {20 User}
 addUserKnob {41 in l "position data" T Shuffle_Input_Channels.in}
 addUserKnob {6 unpremultiply +STARTLINE}
 addUserKnob {6 useAlpha l "ignore outside alpha" -STARTLINE}
 addUserKnob {6 useGPU l "use GPU if available" -STARTLINE}
 useGPU true
 addUserKnob {26 ""}
 addUserKnob {4 noisetype M {fBm turbulent p_rings p_rays Euclidian Voronoi Manhattan Chebyslev Worley "" "" ""}}
 noisetype turbulent
 addUserKnob {6 Trunc l "blocky (trunc)" -STARTLINE}
 addUserKnob {41 Position2d T SampleXY.Position2d}
 addUserKnob {41 rgbSample l center T Sample.rgbSample}
 addUserKnob {6 useCenter -STARTLINE}
 useCenter true
 addUserKnob {26 ""}
 addUserKnob {18 size R 1 100}
 size 2.55
 addUserKnob {6 size_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 size_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 size_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 size_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 seed}
 seed {0 0 0}
 addUserKnob {6 seed_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 seed_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 seed_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 seed_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 seed_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 size_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 truncSize l "blocky size" +HIDDEN R 0 2}
 truncSize 0.5
 addUserKnob {6 truncSize_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 truncSize_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 truncSize_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 ""}
 addUserKnob {7 rays +HIDDEN}
 rays 30
 addUserKnob {7 raysSeed l "rays seed" +HIDDEN R 0 10}
 addUserKnob {7 ringsSeed l "rings seed" +HIDDEN R 0 10}
 addUserKnob {7 range +HIDDEN R 0 6}
 range 1
 addUserKnob {6 invert +HIDDEN +STARTLINE}
 addUserKnob {3 octaves}
 octaves 1
 addUserKnob {7 lacunarity R 1 10}
 lacunarity 1.6
 addUserKnob {7 gain R 0.1 1}
 gain 0.5
 addUserKnob {7 gamma}
 gamma 0.5
 addUserKnob {7 gammaNormalize l gamma +HIDDEN R 0 2}
 gammaNormalize 1
 addUserKnob {26 ""}
 addUserKnob {26 INFO l "" +STARTLINE T "v1.2 (c) Riley Gray and Owen Bulka 2020\nBased on \"Cell Noise v1.1\" by Matthew Shaw     "}
 addUserKnob {26 c44_version_author l "" +STARTLINE T "<span style=\"color:#666\"><br/><b>C44Kernel v1.0</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2018</span>"}
 addUserKnob {20 Transform}
 addUserKnob {41 rot_order l "rotation order" T Axis1.rot_order}
 addUserKnob {41 translate T Axis1.translate}
 addUserKnob {41 rotate T Axis1.rotate}
 addUserKnob {41 scaling l scale T Axis1.scaling}
 addUserKnob {41 uniform_scale l "uniform scale" T Axis1.uniform_scale}
 addUserKnob {41 skew T Axis1.skew}
 addUserKnob {41 pivot +INVISIBLE T Axis1.pivot}
}
 Input {
  inputs 0
  name img
  xpos 0
  ypos -116
 }
 AddChannels {
  channels alpha
  color 1
  name AddChannels1
  xpos 0
  ypos -64
 }
 Shuffle {
  in position
  alpha blue
  out rgb
  name Shuffle_Input_Channels
  xpos 0
  ypos -18
 }
 Unpremult {
  name Unpremult1
  xpos 0
  ypos 16
  disable {{!parent.unpremultiply i}}
 }
 Dot {
  name Dot2
  xpos 34
  ypos 66
 }
set N93b4f20 [stack 0]
 Dot {
  name Dot4
  xpos -130
  ypos 66
 }
set N93b9cc0 [stack 0]
 Dot {
  name Dot3
  xpos -292
  ypos 66
 }
 Expression {
  channel0 alpha
  expr0 "a == 0 ? 1 :0"
  channel1 none
  channel2 none
  channel3 {none none none -rgba.alpha}
  name Expression1
  xpos -326
  ypos 751
 }
 Axis2 {
  inputs 0
  name Axis1
  xpos 265
  ypos 200
 }
push $N93b4f20
 Add {
  channels rgb
  value {{parent.Sample.rgbSample/-1} {parent.Sample.rgbSample/-1} {parent.Sample.rgbSample/-1} 0}
  name center
  xpos 0
  ypos 141
  disable {{1-parent.useCenter}}
 }
 Group {
  inputs 2
  name C44Kernel
  help "C44Kernel v1.0 by Adrian Pueyo\n\nMultiply the rgb or rgba colors by an arbitrary 4x4 Matrix. Useful for transforming a Position pass.\n\nYou can plug in an Axis or Camera node into the axis input, to also apply its transformations.\n\nadrianpueyo.com, 2017"
  tile_color 0xe88543ff
  xpos 0
  ypos 221
  lock_connections true
  addUserKnob {20 C44Kernel}
  addUserKnob {41 channels T MergeIn.Achannels}
  addUserKnob {41 matrix T Axis1.matrix}
  addUserKnob {6 invert -STARTLINE}
  addUserKnob {6 alpha_masking l "alpha masking" t "Apply only where rgba.alpha>0" +STARTLINE}
  addUserKnob {20 advanced l Advanced n 1}
  advanced 0
  addUserKnob {6 transpose +STARTLINE}
  addUserKnob {6 w_divide +STARTLINE}
  addUserKnob {6 rgba_mode l "apply on Vector4" t "Usually you'll want to apply the matrix on the RGB only, which uses a white alpha. Enable this to use the full Vector4 (RGBA)." +STARTLINE}
  addUserKnob {20 endGroup n -1}
  addUserKnob {26 ""}
  addUserKnob {41 mix T MergeOut.mix}
  addUserKnob {26 version_author l "" t "C44Kernel v1.0\n23 June, 2018" +STARTLINE T "<span style=\"color:#666\"><br/><b>C44Kernel v1.0</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2018</span>"}
  addUserKnob {20 GPU_Settings l "GPU Settings"}
  addUserKnob {41 maxGPUMemory l "Percentage of GPU memory to use" T C44MatrixKernel.maxGPUMemory}
  addUserKnob {41 maxTileLines l "Percentage of image height per tile" T C44MatrixKernel.maxTileLines}
 }
  Input {
   inputs 0
   name Inputaxis
   xpos 133
   ypos -181
   number 1
  }
  Axis2 {
   useMatrix true
   name Axis1
   xpos 143
   ypos -133
  }
  Input {
   inputs 0
   name Inputimg
   xpos -110
   ypos -192
  }
set N9415120 [stack 0]
  Dot {
   name Dot1
   xpos -76
   ypos -161
  }
set N941a350 [stack 0]
  Expression {
   expr3 a>0
   name ExpressionA
   xpos -220
   ypos -164
  }
  Switch {
   which {{!parent.alpha_masking}}
   name SwitchMasking
   xpos -220
   ypos -112
  }
push $N941a350
push $N9415120
  Remove {
   name RemoveAll
   xpos 34
   ypos -196
  }
  Merge2 {
   inputs 2
   operation copy
   Bchannels none
   name MergeIn
   xpos 34
   ypos -164
  }
  Shuffle {
   alpha white
   name ShuffleWhiteA
   xpos 34
   ypos -140
   disable {{parent.rgba_mode}}
  }
  BlinkScript {
   recompileCount 147
   ProgramGroup 1
   KernelDescription "2 \"C44MatrixKernel\" iterate pixelWise 10f1841ce0aee43165aca4445fb9ce0126826eedd71da6339f12b8f8de8e52eb 2 \"src\" Read Point \"dst\" Write Point 4 \"m\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"invert\" Int 1 AAAAAA== \"transpose\" Int 1 AAAAAA== \"w_divide\" Int 1 AAAAAA== 4 \"m\" 16 1 \"invert\" 1 1 \"transpose\" 1 1 \"w_divide\" 1 1 0"
   kernelSource "kernel C44MatrixKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float4x4 m;\n    int invert;\n    int transpose;\n    int w_divide;\n\n  void process(int2 pos) \{\n    SampleType(src) p = src();\n    float4 result = 1.0f;\n    float4x4 mi = m;\n    mi = invert?mi.invert():mi;\n    mi = transpose?mi.transpose():mi;\n    for(int c = 0; c<dst.kComps; c++)\{\n      result\[c] = mi\[c]\[0]*p.x + mi\[c]\[1]*p.y + mi\[c]\[2]*p.z + mi\[c]\[3]*p.w;\n    \}\n    dst() = w_divide?result/result.w:result;\n  \}\n\};\n"
   rebuild ""
   C44MatrixKernel_m {
       {{Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix}}
       {{Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix}}
       {{Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix}}
       {{Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix}}
     }
   C44MatrixKernel_invert {{parent.invert}}
   C44MatrixKernel_transpose {{parent.transpose}}
   C44MatrixKernel_w_divide {{parent.w_divide}}
   rebuild_finalise ""
   name C44MatrixKernel
   xpos 34
   ypos -116
  }
push $N941a350
  Merge2 {
   inputs 2+1
   operation copy
   Bchannels {{{parent.MergeIn.Achannels}}}
   output {{{parent.MergeIn.Achannels}}}
   name MergeOut
   xpos -110
   ypos -112
  }
  Output {
   name Output1
   xpos -110
   ypos -88
  }
 end_group
 Add {
  channels rgb
  value {{parent.seed} {parent.seed} {parent.seed} {parent.seed}}
  name Seed
  xpos 0
  ypos 279
 }
 Multiply {
  channels rgb
  value {{10/parent.size} {10/parent.size} {10/parent.size} {10/parent.size}}
  name size
  xpos 0
  ypos 327
 }
 Expression {
  expr0 trunc(r*truncScale.r)/truncScale.r/.95
  expr1 trunc(g*truncScale.g)/truncScale.g/.95
  expr2 trunc(b*truncScale.b)/truncScale.b/.95
  name Trunc
  xpos 0
  ypos 391
  disable {{1-parent.Trunc}}
  addUserKnob {20 User}
  addUserKnob {18 truncScale R 0.1 10}
  truncScale {{1/parent.truncSize} {1/parent.truncSize} {1/parent.truncSize}}
  addUserKnob {6 truncScale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 truncScale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 truncScale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 truncScale_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 }
 Dot {
  name Dot1
  xpos 34
  ypos 469
 }
set N94b4f20 [stack 0]
 BlinkScript {
  recompileCount 6
  ProgramGroup 1
  KernelDescription "2 \"Worley\" iterate pixelWise cd00b03232e0b755cf1f537751b291ec18e739c23a26daa3a40693e1bd7ed6d8 2 \"position_pass\" Read Point \"dst\" Write Point 1 \"Invert\" Bool 1 AA== 1 \"invert\" 1 1 0"
  kernelSource "// https://aftbit.com/cell-noise-2/\n\n// C++11\n#define rand_multiplier 48271\n#define rand_increment  0\n#define rand_modulus    2147483647\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\n#define OFFSET_BASIS 2166136261\n#define FNV_PRIME 16777619\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\n#define one    393325350\n#define two   1022645910\n#define three 1861739990\n#define four  2700834071\n#define five  3372109335\n#define six   3819626178\n#define seven 4075350088\n#define eight 4203212043\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n\n// Blink Kernel\nkernel Worley : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint> position_pass;\n  Image<eWrite> dst;\n\n  param:\n    bool invert;\n\n  void define()\n  \{\n    defineParam(invert, \"Invert\", false);\n  \}\n\n  void process()\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float distance = 6666.0f;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float4 position = position_pass();\n    float3 input = float3(position.x, position.y, position.z);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              distance = min(distance, dot(input - featurePoint, input - featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    distance = sqrt(distance);\n    if (invert)\n      distance = 1.0f - distance;\n    dst() = distance;\n\n  \}\n\n\};"
  useGPUIfAvailable {{parent.useGPU}}
  rebuild ""
  Worley_Invert {{parent.invert}}
  rebuild_finalise ""
  name WorleyNoise
  xpos 990
  ypos 579
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma2
  xpos 990
  ypos 615
 }
push $N94b4f20
 BlinkScript {
  recompileCount 5
  ProgramGroup 1
  KernelDescription "2 \"ChebyshevNoise\" iterate pixelWise 0696bc3791972a27cd4c68d2990c354a3c7c98ff58f45dc3e525fa28b235bbf4 2 \"position_pass\" Read Point \"dst\" Write Point 1 \"Range\" Float 1 AABAQA== 1 \"range\" 1 1 2 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA=="
  kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\n#define rand_multiplier 48271\n#define rand_increment  0\n#define rand_modulus    2147483647\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\n#define OFFSET_BASIS 2166136261\n#define FNV_PRIME 16777619\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\n#define one    393325350\n#define two   1022645910\n#define three 1861739990\n#define four  2700834071\n#define five  3372109335\n#define six   3819626178\n#define seven 4075350088\n#define eight 4203212043\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ChebyshevNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint> position_pass;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n\n  local:\n    float fRange;\n    int iRange;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n  \}\n\n  void process()\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 position = position_pass();\n    float3 input = float3(position.x, position.y, position.z);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ChebyshevDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    dst() = color;\n\n  \}\n\n\};"
  useGPUIfAvailable {{parent.useGPU}}
  rebuild ""
  ChebyshevNoise_Range {{parent.range}}
  format {{{WorleyNoise.format}}}
  rebuild_finalise ""
  name ChebyShevNoise
  xpos 880
  ypos 578
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma3
  xpos 880
  ypos 614
 }
push $N94b4f20
 BlinkScript {
  recompileCount 16
  ProgramGroup 1
  KernelDescription "2 \"ManhattanNoise\" iterate pixelWise fdbb8a014c9cd7c179e23ccd0729d0213a232c394b85e9bf56c91c66207ca1d2 2 \"position_pass\" Read Point \"dst\" Write Point 1 \"Range\" Float 1 AABAQA== 1 \"range\" 1 1 2 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA=="
  kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\n#define rand_multiplier 48271\n#define rand_increment  0\n#define rand_modulus    2147483647\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\n#define OFFSET_BASIS 2166136261\n#define FNV_PRIME 16777619\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\n#define one    393325350\n#define two   1022645910\n#define three 1861739990\n#define four  2700834071\n#define five  3372109335\n#define six   3819626178\n#define seven 4075350088\n#define eight 4203212043\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n// Blink Kernel\nkernel ManhattanNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint> position_pass;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n\n  local:\n    float fRange;\n    int iRange;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n  \}\n\n  void process()\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 position = position_pass();\n    float3 input = float3(position.x, position.y, position.z);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ManhattanDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    dst() = color;\n\n  \}\n\n\};"
  useGPUIfAvailable {{parent.useGPU}}
  rebuild ""
  ManhattanNoise_Range {{parent.range}}
  format {{{WorleyNoise.format}}}
  rebuild_finalise ""
  name ManhattanNoise
  xpos 770
  ypos 577
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma4
  xpos 770
  ypos 615
 }
push $N94b4f20
 BlinkScript {
  recompileCount 16
  KernelDescription "2 \"VoronoiNoise\" iterate pixelWise b5254626cd5df5ff862ca8817e176a1b623927081c48080950344a31c6d0cf9e 2 \"position_pass\" Read Point \"dst\" Write Point 1 \"Range\" Float 1 AABAQA== 1 \"range\" 1 1 2 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA=="
  kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\n#define rand_multiplier 48271\n#define rand_increment  0\n#define rand_modulus    2147483647\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\n#define OFFSET_BASIS 2166136261\n#define FNV_PRIME 16777619\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\n#define one    393325350\n#define two   1022645910\n#define three 1861739990\n#define four  2700834071\n#define five  3372109335\n#define six   3819626178\n#define seven 4075350088\n#define eight 4203212043\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], int idArr\[], float value, int id)\n\{\n  float temp;\n  int tempID;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    tempID = idArr\[i];\n    arr\[i] = value;\n    idArr\[i] = id;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n      idArr\[i + 1] = tempID;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel VoronoiNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint> position_pass;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    \n  local:\n    float fRange;\n    int iRange;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n  \}\n\n  void process()\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n    int idArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 position = position_pass();\n    float3 input = float3(position.x, position.y, position.z);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            id = lastRandom;\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, idArray, length(input - featurePoint), id+l);\n            \}\n        \}\n      \}\n    \}\n\n    float3 col = float3(float(idArray\[iRange]) / rand_modulus, 0.0f, 0.0f);\n    lastRandom = lcgRandom(idArray\[iRange]);\n    col.y = float(lastRandom) / rand_modulus;\n    lastRandom = lcgRandom(lastRandom);\n    col.z = float(lastRandom) / rand_modulus;\n\n    for(int component = 0; component < 3; component++)\n      dst(component) = col\[component];\n    dst(3) = 1.0f;\n  \}\n\n\};"
  useGPUIfAvailable {{parent.useGPU}}
  rebuild ""
  VoronoiNoise_Range {{parent.range}}
  format {{{WorleyNoise.format}}}
  rebuild_finalise ""
  name VoronoiNoise
  xpos 658
  ypos 579
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma5
  xpos 658
  ypos 615
 }
push $N94b4f20
 BlinkScript {
  recompileCount 18
  KernelDescription "2 \"EuclidianNoise\" iterate pixelWise dbf5e83c1b46011f2fc8e7b81e879b31ef00feccf8756cfeccd2d9e033e58784 2 \"position_pass\" Read Point \"dst\" Write Point 1 \"Range\" Float 1 AABAQA== 1 \"range\" 1 1 2 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA=="
  kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\n#define rand_multiplier 48271\n#define rand_increment  0\n#define rand_modulus    2147483647\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\n#define OFFSET_BASIS 2166136261\n#define FNV_PRIME 16777619\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\n#define one    393325350\n#define two   1022645910\n#define three 1861739990\n#define four  2700834071\n#define five  3372109335\n#define six   3819626178\n#define seven 4075350088\n#define eight 4203212043\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel EuclidianNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint> position_pass;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n\n  local:\n    float fRange;\n    int iRange;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n  \}\n\n  void process()\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 position = position_pass();\n    float3 input = float3(position.x, position.y, position.z);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, EuclidianDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    dst() = color;\n\n  \}\n\n\};"
  useGPUIfAvailable {{parent.useGPU}}
  rebuild ""
  EuclidianNoise_Range {{parent.range}}
  format {{{WorleyNoise.format}}}
  rebuild_finalise ""
  name EuclidianNoise
  selected true
  xpos 550
  ypos 572
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma6
  xpos 550
  ypos 615
 }
push $N94b4f20
 Expression {
  channel0 rgba
  expr0 "sin( atan(r, g) *this.rays+this.rays_seed)"
  channel1 none
  channel2 none
  name rays
  xpos 400
  ypos 582
  addUserKnob {20 User}
  addUserKnob {7 rays}
  rays {{parent.rays}}
  addUserKnob {7 rays_seed l "rays seed"}
  rays_seed {{parent.raysSeed}}
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma7
  xpos 400
  ypos 606
 }
push $N94b4f20
 Expression {
  channel0 rgba
  expr0 "sin(sqrt( r*r + g*g + b*b)+this.rings_seed)"
  channel1 none
  channel2 none
  name rings
  xpos 259
  ypos 581
  addUserKnob {20 User}
  addUserKnob {7 rings_seed l "rings seed"}
  rings_seed {{parent.ringsSeed}}
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma8
  xpos 259
  ypos 605
 }
push $N94b4f20
 Expression {
  channel0 rgba
  expr0 "pow(turbulence (r, g, b, this.octaves, this.lacunarity, this.gain), 1/this.gamma)"
  channel1 none
  channel2 none
  channel3 {none none none -rgba.alpha}
  name Turb
  xpos 128
  ypos 578
  addUserKnob {20 User}
  addUserKnob {3 octaves}
  octaves {{parent.octaves}}
  addUserKnob {7 lacunarity R 1 10}
  lacunarity {{parent.lacunarity}}
  addUserKnob {7 gain R 0.1 1}
  gain {{parent.gain}}
  addUserKnob {7 gamma}
  gamma {{parent.gamma}}
 }
push $N94b4f20
 Expression {
  channel0 rgba
  expr0 "pow((fBm (r, g, b, this.octaves, this.lacunarity, this.gain) +1)/2, 1/this.gamma)"
  channel1 none
  channel2 none
  channel3 {none none none -rgba.alpha}
  name FBM
  xpos 0
  ypos 577
  addUserKnob {20 User}
  addUserKnob {3 octaves}
  octaves {{parent.octaves}}
  addUserKnob {7 lacunarity R 1 10}
  lacunarity {{parent.lacunarity}}
  addUserKnob {7 gain R 0.1 1}
  gain {{parent.gain}}
  addUserKnob {7 gamma}
  gamma {{parent.gamma}}
 }
 Switch {
  inputs 9
  which {{noisetype}}
  name Type
  xpos 0
  ypos 692
 }
 Multiply {
  inputs 1+1
  channels rgba
  value 0
  name Multiply1
  xpos 0
  ypos 751
  disable {{1-parent.useAlpha}}
 }
 Output {
  name Output1
  xpos 0
  ypos 885
 }
push $N93b9cc0
 NoOp {
  name SampleXY
  knobChanged "\nn = nuke.thisNode()\nrgbNode = nuke.toNode('Sample')\nposition = n.knob('Position2d').getValue()\npositionX = position\[0]\npositionY = position\[-1]\nrSample = n.sample(\"r\",positionX,positionY)\ngSample = n.sample(\"g\",positionX,positionY)\nbSample = n.sample(\"b\",positionX,positionY)\nrgbNode.knob('rgbSample').setValue(\[rSample, gSample, bSample])\n"
  xpos -164
  ypos 95
  addUserKnob {20 User}
  addUserKnob {12 Position2d}
  Position2d {914 591}
 }
 NoOp {
  inputs 0
  name Sample
  xpos -162
  ypos 140
  addUserKnob {20 User}
  addUserKnob {18 rgbSample}
  rgbSample {0 0 0}
  addUserKnob {6 rgbSample_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 }
end_group
Shuffle2 {
 inputs 2
 fromInput1 {{0} B A}
 fromInput2 {{1} B A}
 in2 rgba
 out2 rgba
 mappings "8 rgba.red 0 0 rgba.alpha 0 3 rgba.blue 1 2 rgba.blue 1 2 black -1 -1 rgba.green 0 1 black -1 -1 rgba.red 0 0 black -1 -1 rgba.blue 0 2 rgba.red 1 0 rgba.red 1 0 rgba.green 1 1 rgba.green 1 1 black -1 -1 rgba.alpha 1 3"
 name Shuffle1
 xpos 401
 ypos -9
}
push $N8d587c0
Dot {
 name Dot3
 xpos 16
 ypos -61
}
Constant {
 inputs 0
 color {1 0.5 0.2 1}
 name Constant1
 xpos 64
 ypos -71
}
push $N8d587c0
Group {
 name P_Noise_Advanced3
 knobChanged "\nn = nuke.thisNode()\ntype = n\['noisetype'].value()\nblock = n\['Trunc'].getValue()\nVis = \[]\nHide = \[]\nif type in ('fBm', 'turbulent'):\n    Vis.extend(\['octaves', 'lacunarity', 'gain', 'gamma'])\n    Hide.extend(\['rays', 'range', 'invert', 'ringsSeed', 'raysSeed', 'gammaNormalize'])   \nelif type == 'p_rings':\n    Vis.extend(\['ringsSeed', 'gammaNormalize'])\n    Hide.extend(\['rays', 'range', 'invert', 'octaves', 'lacunarity', 'gain', 'gamma', 'raysSeed'])\nelif type == 'p_rays':\n    Vis.extend(\['rays', 'raysSeed', 'gammaNormalize'])\n    Hide.extend(\['range', 'invert', 'octaves', 'lacunarity', 'gain', 'gamma', 'ringsSeed'])\nelif type in ('Euclidian', 'Voronoi', 'Manhattan', 'ChebyShev'):\n    Vis.extend(\['range', 'gammaNormalize'])\n    Hide.extend(\['rays', 'invert', 'octaves', 'lacunarity', 'gain', 'gamma', 'ringsSeed', 'raysSeed'])\nelif type == 'Worley':\n    Vis.extend(\['invert', 'gammaNormalize'])\n    Hide.extend(\['rays', 'range', 'octaves', 'lacunarity', 'gain', 'gamma', 'ringsSeed', 'raysSeed'])\nfor r in Vis: n\[r].setVisible(True)\nfor x in Hide: n\[x].setVisible(False)\n\nif block == True:\n    n\['truncSize'].setVisible(True)\nelse:\n    n\['truncSize'].setVisible(False)\n"
 label "(\[value in])"
 xpos 139
 ypos -106
 addUserKnob {20 User}
 addUserKnob {41 in l "position data" T Shuffle_Input_Channels.in}
 addUserKnob {6 unpremultiply +STARTLINE}
 addUserKnob {6 useAlpha l "ignore outside alpha" -STARTLINE}
 addUserKnob {6 useGPU l "use GPU if available" -STARTLINE}
 useGPU true
 addUserKnob {26 ""}
 addUserKnob {4 noisetype M {fBm turbulent p_rings p_rays Euclidian Voronoi Manhattan Chebyslev Worley "" "" ""}}
 noisetype turbulent
 addUserKnob {6 Trunc l "blocky (trunc)" -STARTLINE}
 addUserKnob {41 Position2d T SampleXY.Position2d}
 addUserKnob {41 rgbSample l center T Sample.rgbSample}
 addUserKnob {6 useCenter -STARTLINE}
 useCenter true
 addUserKnob {26 ""}
 addUserKnob {18 size R 1 100}
 size 2.55
 addUserKnob {6 size_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 size_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 size_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 size_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 seed}
 seed {0 0 0}
 addUserKnob {6 seed_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 seed_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 seed_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 seed_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 seed_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 size_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 truncSize l "blocky size" +HIDDEN R 0 2}
 truncSize 0.5
 addUserKnob {6 truncSize_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 truncSize_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 truncSize_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 ""}
 addUserKnob {7 rays +HIDDEN}
 rays 30
 addUserKnob {7 raysSeed l "rays seed" +HIDDEN R 0 10}
 addUserKnob {7 ringsSeed l "rings seed" +HIDDEN R 0 10}
 addUserKnob {7 range +HIDDEN R 0 6}
 range 1
 addUserKnob {6 invert +HIDDEN +STARTLINE}
 addUserKnob {3 octaves}
 octaves 1
 addUserKnob {7 lacunarity R 1 10}
 lacunarity 1.6
 addUserKnob {7 gain R 0.1 1}
 gain 0.5
 addUserKnob {7 gamma}
 gamma 0.5
 addUserKnob {7 gammaNormalize l gamma +HIDDEN R 0 2}
 gammaNormalize 1
 addUserKnob {26 ""}
 addUserKnob {26 INFO l "" +STARTLINE T "v1.2 (c) Riley Gray and Owen Bulka 2020\nBased on \"Cell Noise v1.1\" by Matthew Shaw     "}
 addUserKnob {26 c44_version_author l "" +STARTLINE T "<span style=\"color:#666\"><br/><b>C44Kernel v1.0</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2018</span>"}
 addUserKnob {20 Transform}
 addUserKnob {41 rot_order l "rotation order" T Axis1.rot_order}
 addUserKnob {41 translate T Axis1.translate}
 addUserKnob {41 rotate T Axis1.rotate}
 addUserKnob {41 scaling l scale T Axis1.scaling}
 addUserKnob {41 uniform_scale l "uniform scale" T Axis1.uniform_scale}
 addUserKnob {41 skew T Axis1.skew}
 addUserKnob {41 pivot +INVISIBLE T Axis1.pivot}
}
 Input {
  inputs 0
  name img
  xpos 0
  ypos -116
 }
 AddChannels {
  channels alpha
  color 1
  name AddChannels1
  xpos 0
  ypos -64
 }
 Shuffle {
  in position
  alpha blue
  out rgb
  name Shuffle_Input_Channels
  xpos 0
  ypos -18
 }
 Unpremult {
  name Unpremult1
  xpos 0
  ypos 16
  disable {{!parent.unpremultiply i}}
 }
 Dot {
  name Dot2
  xpos 34
  ypos 66
 }
set N962a0f0 [stack 0]
 Dot {
  name Dot4
  xpos -130
  ypos 66
 }
set N962f0a0 [stack 0]
 Dot {
  name Dot3
  xpos -292
  ypos 66
 }
 Expression {
  channel0 alpha
  expr0 "a == 0 ? 1 :0"
  channel1 none
  channel2 none
  channel3 {none none none -rgba.alpha}
  name Expression1
  xpos -326
  ypos 751
 }
 Axis2 {
  inputs 0
  name Axis1
  xpos 265
  ypos 200
 }
push $N962a0f0
 Add {
  channels rgb
  value {{parent.Sample.rgbSample/-1} {parent.Sample.rgbSample/-1} {parent.Sample.rgbSample/-1} 0}
  name center
  xpos 0
  ypos 141
  disable {{1-parent.useCenter}}
 }
 Group {
  inputs 2
  name C44Kernel
  help "C44Kernel v1.0 by Adrian Pueyo\n\nMultiply the rgb or rgba colors by an arbitrary 4x4 Matrix. Useful for transforming a Position pass.\n\nYou can plug in an Axis or Camera node into the axis input, to also apply its transformations.\n\nadrianpueyo.com, 2017"
  tile_color 0xe88543ff
  xpos 0
  ypos 221
  lock_connections true
  addUserKnob {20 C44Kernel}
  addUserKnob {41 channels T MergeIn.Achannels}
  addUserKnob {41 matrix T Axis1.matrix}
  addUserKnob {6 invert -STARTLINE}
  addUserKnob {6 alpha_masking l "alpha masking" t "Apply only where rgba.alpha>0" +STARTLINE}
  addUserKnob {20 advanced l Advanced n 1}
  advanced 0
  addUserKnob {6 transpose +STARTLINE}
  addUserKnob {6 w_divide +STARTLINE}
  addUserKnob {6 rgba_mode l "apply on Vector4" t "Usually you'll want to apply the matrix on the RGB only, which uses a white alpha. Enable this to use the full Vector4 (RGBA)." +STARTLINE}
  addUserKnob {20 endGroup n -1}
  addUserKnob {26 ""}
  addUserKnob {41 mix T MergeOut.mix}
  addUserKnob {26 version_author l "" t "C44Kernel v1.0\n23 June, 2018" +STARTLINE T "<span style=\"color:#666\"><br/><b>C44Kernel v1.0</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2018</span>"}
  addUserKnob {20 GPU_Settings l "GPU Settings"}
  addUserKnob {41 maxGPUMemory l "Percentage of GPU memory to use" T C44MatrixKernel.maxGPUMemory}
  addUserKnob {41 maxTileLines l "Percentage of image height per tile" T C44MatrixKernel.maxTileLines}
 }
  Input {
   inputs 0
   name Inputaxis
   xpos 133
   ypos -181
   number 1
  }
  Axis2 {
   useMatrix true
   name Axis1
   xpos 143
   ypos -133
  }
  Input {
   inputs 0
   name Inputimg
   xpos -110
   ypos -192
  }
set N968a600 [stack 0]
  Dot {
   name Dot1
   xpos -76
   ypos -161
  }
set N968f830 [stack 0]
  Expression {
   expr3 a>0
   name ExpressionA
   xpos -220
   ypos -164
  }
  Switch {
   which {{!parent.alpha_masking}}
   name SwitchMasking
   xpos -220
   ypos -112
  }
push $N968f830
push $N968a600
  Remove {
   name RemoveAll
   xpos 34
   ypos -196
  }
  Merge2 {
   inputs 2
   operation copy
   Bchannels none
   name MergeIn
   xpos 34
   ypos -164
  }
  Shuffle {
   alpha white
   name ShuffleWhiteA
   xpos 34
   ypos -140
   disable {{parent.rgba_mode}}
  }
  BlinkScript {
   recompileCount 147
   ProgramGroup 1
   KernelDescription "2 \"C44MatrixKernel\" iterate pixelWise 10f1841ce0aee43165aca4445fb9ce0126826eedd71da6339f12b8f8de8e52eb 2 \"src\" Read Point \"dst\" Write Point 4 \"m\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"invert\" Int 1 AAAAAA== \"transpose\" Int 1 AAAAAA== \"w_divide\" Int 1 AAAAAA== 4 \"m\" 16 1 \"invert\" 1 1 \"transpose\" 1 1 \"w_divide\" 1 1 0"
   kernelSource "kernel C44MatrixKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float4x4 m;\n    int invert;\n    int transpose;\n    int w_divide;\n\n  void process(int2 pos) \{\n    SampleType(src) p = src();\n    float4 result = 1.0f;\n    float4x4 mi = m;\n    mi = invert?mi.invert():mi;\n    mi = transpose?mi.transpose():mi;\n    for(int c = 0; c<dst.kComps; c++)\{\n      result\[c] = mi\[c]\[0]*p.x + mi\[c]\[1]*p.y + mi\[c]\[2]*p.z + mi\[c]\[3]*p.w;\n    \}\n    dst() = w_divide?result/result.w:result;\n  \}\n\};\n"
   rebuild ""
   C44MatrixKernel_m {
       {{Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix}}
       {{Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix}}
       {{Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix}}
       {{Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix} {Axis1.world_matrix}}
     }
   C44MatrixKernel_invert {{parent.invert}}
   C44MatrixKernel_transpose {{parent.transpose}}
   C44MatrixKernel_w_divide {{parent.w_divide}}
   rebuild_finalise ""
   name C44MatrixKernel
   xpos 34
   ypos -116
  }
push $N968f830
  Merge2 {
   inputs 2+1
   operation copy
   Bchannels {{{parent.MergeIn.Achannels}}}
   output {{{parent.MergeIn.Achannels}}}
   name MergeOut
   xpos -110
   ypos -112
  }
  Output {
   name Output1
   xpos -110
   ypos -88
  }
 end_group
 Add {
  channels rgb
  value {{parent.seed} {parent.seed} {parent.seed} {parent.seed}}
  name Seed
  xpos 0
  ypos 279
 }
 Multiply {
  channels rgb
  value {{10/parent.size} {10/parent.size} {10/parent.size} {10/parent.size}}
  name size
  xpos 0
  ypos 327
 }
 Expression {
  expr0 trunc(r*truncScale.r)/truncScale.r/.95
  expr1 trunc(g*truncScale.g)/truncScale.g/.95
  expr2 trunc(b*truncScale.b)/truncScale.b/.95
  name Trunc
  xpos 0
  ypos 391
  disable {{1-parent.Trunc}}
  addUserKnob {20 User}
  addUserKnob {18 truncScale R 0.1 10}
  truncScale {{1/parent.truncSize} {1/parent.truncSize} {1/parent.truncSize}}
  addUserKnob {6 truncScale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 truncScale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 truncScale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 truncScale_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 }
 Dot {
  name Dot1
  xpos 34
  ypos 469
 }
set N972a910 [stack 0]
 BlinkScript {
  recompileCount 6
  ProgramGroup 1
  KernelDescription "2 \"Worley\" iterate pixelWise cd00b03232e0b755cf1f537751b291ec18e739c23a26daa3a40693e1bd7ed6d8 2 \"position_pass\" Read Point \"dst\" Write Point 1 \"Invert\" Bool 1 AA== 1 \"invert\" 1 1 0"
  kernelSource "// https://aftbit.com/cell-noise-2/\n\n// C++11\n#define rand_multiplier 48271\n#define rand_increment  0\n#define rand_modulus    2147483647\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\n#define OFFSET_BASIS 2166136261\n#define FNV_PRIME 16777619\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\n#define one    393325350\n#define two   1022645910\n#define three 1861739990\n#define four  2700834071\n#define five  3372109335\n#define six   3819626178\n#define seven 4075350088\n#define eight 4203212043\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n\n// Blink Kernel\nkernel Worley : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint> position_pass;\n  Image<eWrite> dst;\n\n  param:\n    bool invert;\n\n  void define()\n  \{\n    defineParam(invert, \"Invert\", false);\n  \}\n\n  void process()\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float distance = 6666.0f;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float4 position = position_pass();\n    float3 input = float3(position.x, position.y, position.z);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              distance = min(distance, dot(input - featurePoint, input - featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    distance = sqrt(distance);\n    if (invert)\n      distance = 1.0f - distance;\n    dst() = distance;\n\n  \}\n\n\};"
  useGPUIfAvailable {{parent.useGPU}}
  rebuild ""
  Worley_Invert {{parent.invert}}
  rebuild_finalise ""
  name WorleyNoise
  xpos 990
  ypos 579
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma2
  xpos 990
  ypos 615
 }
push $N972a910
 BlinkScript {
  recompileCount 5
  ProgramGroup 1
  KernelDescription "2 \"ChebyshevNoise\" iterate pixelWise 0696bc3791972a27cd4c68d2990c354a3c7c98ff58f45dc3e525fa28b235bbf4 2 \"position_pass\" Read Point \"dst\" Write Point 1 \"Range\" Float 1 AABAQA== 1 \"range\" 1 1 2 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA=="
  kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\n#define rand_multiplier 48271\n#define rand_increment  0\n#define rand_modulus    2147483647\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\n#define OFFSET_BASIS 2166136261\n#define FNV_PRIME 16777619\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\n#define one    393325350\n#define two   1022645910\n#define three 1861739990\n#define four  2700834071\n#define five  3372109335\n#define six   3819626178\n#define seven 4075350088\n#define eight 4203212043\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ChebyshevNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint> position_pass;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n\n  local:\n    float fRange;\n    int iRange;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n  \}\n\n  void process()\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 position = position_pass();\n    float3 input = float3(position.x, position.y, position.z);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ChebyshevDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    dst() = color;\n\n  \}\n\n\};"
  useGPUIfAvailable {{parent.useGPU}}
  rebuild ""
  ChebyshevNoise_Range {{parent.range}}
  format {{{WorleyNoise.format}}}
  rebuild_finalise ""
  name ChebyShevNoise
  xpos 880
  ypos 578
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma3
  xpos 880
  ypos 614
 }
push $N972a910
 BlinkScript {
  recompileCount 16
  ProgramGroup 1
  KernelDescription "2 \"ManhattanNoise\" iterate pixelWise fdbb8a014c9cd7c179e23ccd0729d0213a232c394b85e9bf56c91c66207ca1d2 2 \"position_pass\" Read Point \"dst\" Write Point 1 \"Range\" Float 1 AABAQA== 1 \"range\" 1 1 2 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA=="
  kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\n#define rand_multiplier 48271\n#define rand_increment  0\n#define rand_modulus    2147483647\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\n#define OFFSET_BASIS 2166136261\n#define FNV_PRIME 16777619\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\n#define one    393325350\n#define two   1022645910\n#define three 1861739990\n#define four  2700834071\n#define five  3372109335\n#define six   3819626178\n#define seven 4075350088\n#define eight 4203212043\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n// Blink Kernel\nkernel ManhattanNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint> position_pass;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n\n  local:\n    float fRange;\n    int iRange;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n  \}\n\n  void process()\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 position = position_pass();\n    float3 input = float3(position.x, position.y, position.z);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ManhattanDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    dst() = color;\n\n  \}\n\n\};"
  useGPUIfAvailable {{parent.useGPU}}
  rebuild ""
  ManhattanNoise_Range {{parent.range}}
  format {{{WorleyNoise.format}}}
  rebuild_finalise ""
  name ManhattanNoise
  xpos 770
  ypos 577
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma4
  xpos 770
  ypos 615
 }
push $N972a910
 BlinkScript {
  recompileCount 16
  KernelDescription "2 \"VoronoiNoise\" iterate pixelWise b5254626cd5df5ff862ca8817e176a1b623927081c48080950344a31c6d0cf9e 2 \"position_pass\" Read Point \"dst\" Write Point 1 \"Range\" Float 1 AABAQA== 1 \"range\" 1 1 2 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA=="
  kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\n#define rand_multiplier 48271\n#define rand_increment  0\n#define rand_modulus    2147483647\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\n#define OFFSET_BASIS 2166136261\n#define FNV_PRIME 16777619\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\n#define one    393325350\n#define two   1022645910\n#define three 1861739990\n#define four  2700834071\n#define five  3372109335\n#define six   3819626178\n#define seven 4075350088\n#define eight 4203212043\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], int idArr\[], float value, int id)\n\{\n  float temp;\n  int tempID;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    tempID = idArr\[i];\n    arr\[i] = value;\n    idArr\[i] = id;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n      idArr\[i + 1] = tempID;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel VoronoiNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint> position_pass;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    \n  local:\n    float fRange;\n    int iRange;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n  \}\n\n  void process()\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n    int idArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 position = position_pass();\n    float3 input = float3(position.x, position.y, position.z);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            id = lastRandom;\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, idArray, length(input - featurePoint), id+l);\n            \}\n        \}\n      \}\n    \}\n\n    float3 col = float3(float(idArray\[iRange]) / rand_modulus, 0.0f, 0.0f);\n    lastRandom = lcgRandom(idArray\[iRange]);\n    col.y = float(lastRandom) / rand_modulus;\n    lastRandom = lcgRandom(lastRandom);\n    col.z = float(lastRandom) / rand_modulus;\n\n    for(int component = 0; component < 3; component++)\n      dst(component) = col\[component];\n    dst(3) = 1.0f;\n  \}\n\n\};"
  useGPUIfAvailable {{parent.useGPU}}
  rebuild ""
  VoronoiNoise_Range {{parent.range}}
  format {{{WorleyNoise.format}}}
  rebuild_finalise ""
  name VoronoiNoise
  xpos 658
  ypos 579
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma5
  xpos 658
  ypos 615
 }
push $N972a910
 BlinkScript {
  recompileCount 18
  KernelDescription "2 \"EuclidianNoise\" iterate pixelWise dbf5e83c1b46011f2fc8e7b81e879b31ef00feccf8756cfeccd2d9e033e58784 2 \"position_pass\" Read Point \"dst\" Write Point 1 \"Range\" Float 1 AABAQA== 1 \"range\" 1 1 2 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA=="
  kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\n#define rand_multiplier 48271\n#define rand_increment  0\n#define rand_modulus    2147483647\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\n#define OFFSET_BASIS 2166136261\n#define FNV_PRIME 16777619\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\n#define one    393325350\n#define two   1022645910\n#define three 1861739990\n#define four  2700834071\n#define five  3372109335\n#define six   3819626178\n#define seven 4075350088\n#define eight 4203212043\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel EuclidianNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint> position_pass;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n\n  local:\n    float fRange;\n    int iRange;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n  \}\n\n  void process()\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 position = position_pass();\n    float3 input = float3(position.x, position.y, position.z);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, EuclidianDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    dst() = color;\n\n  \}\n\n\};"
  useGPUIfAvailable {{parent.useGPU}}
  rebuild ""
  EuclidianNoise_Range {{parent.range}}
  format {{{WorleyNoise.format}}}
  rebuild_finalise ""
  name EuclidianNoise
  selected true
  xpos 550
  ypos 572
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma6
  xpos 550
  ypos 615
 }
push $N972a910
 Expression {
  channel0 rgba
  expr0 "sin( atan(r, g) *this.rays+this.rays_seed)"
  channel1 none
  channel2 none
  name rays
  xpos 400
  ypos 582
  addUserKnob {20 User}
  addUserKnob {7 rays}
  rays {{parent.rays}}
  addUserKnob {7 rays_seed l "rays seed"}
  rays_seed {{parent.raysSeed}}
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma7
  xpos 400
  ypos 606
 }
push $N972a910
 Expression {
  channel0 rgba
  expr0 "sin(sqrt( r*r + g*g + b*b)+this.rings_seed)"
  channel1 none
  channel2 none
  name rings
  xpos 259
  ypos 581
  addUserKnob {20 User}
  addUserKnob {7 rings_seed l "rings seed"}
  rings_seed {{parent.ringsSeed}}
 }
 Gamma {
  channels rgba
  value {{parent.gammaNormalize}}
  name Gamma8
  xpos 259
  ypos 605
 }
push $N972a910
 Expression {
  channel0 rgba
  expr0 "pow(turbulence (r, g, b, this.octaves, this.lacunarity, this.gain), 1/this.gamma)"
  channel1 none
  channel2 none
  channel3 {none none none -rgba.alpha}
  name Turb
  xpos 128
  ypos 578
  addUserKnob {20 User}
  addUserKnob {3 octaves}
  octaves {{parent.octaves}}
  addUserKnob {7 lacunarity R 1 10}
  lacunarity {{parent.lacunarity}}
  addUserKnob {7 gain R 0.1 1}
  gain {{parent.gain}}
  addUserKnob {7 gamma}
  gamma {{parent.gamma}}
 }
push $N972a910
 Expression {
  channel0 rgba
  expr0 "pow((fBm (r, g, b, this.octaves, this.lacunarity, this.gain) +1)/2, 1/this.gamma)"
  channel1 none
  channel2 none
  channel3 {none none none -rgba.alpha}
  name FBM
  xpos 0
  ypos 577
  addUserKnob {20 User}
  addUserKnob {3 octaves}
  octaves {{parent.octaves}}
  addUserKnob {7 lacunarity R 1 10}
  lacunarity {{parent.lacunarity}}
  addUserKnob {7 gain R 0.1 1}
  gain {{parent.gain}}
  addUserKnob {7 gamma}
  gamma {{parent.gamma}}
 }
 Switch {
  inputs 9
  which {{noisetype}}
  name Type
  xpos 0
  ypos 692
 }
 Multiply {
  inputs 1+1
  channels rgba
  value 0
  name Multiply1
  xpos 0
  ypos 751
  disable {{1-parent.useAlpha}}
 }
 Output {
  name Output1
  xpos 0
  ypos 885
 }
push $N962f0a0
 NoOp {
  name SampleXY
  knobChanged "\nn = nuke.thisNode()\nrgbNode = nuke.toNode('Sample')\nposition = n.knob('Position2d').getValue()\npositionX = position\[0]\npositionY = position\[-1]\nrSample = n.sample(\"r\",positionX,positionY)\ngSample = n.sample(\"g\",positionX,positionY)\nbSample = n.sample(\"b\",positionX,positionY)\nrgbNode.knob('rgbSample').setValue(\[rSample, gSample, bSample])\n"
  xpos -164
  ypos 95
  addUserKnob {20 User}
  addUserKnob {12 Position2d}
  Position2d {914 591}
 }
 NoOp {
  inputs 0
  name Sample
  xpos -162
  ypos 140
  addUserKnob {20 User}
  addUserKnob {18 rgbSample}
  rgbSample {0 0 0}
  addUserKnob {6 rgbSample_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 rgbSample_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 }
end_group
Shuffle2 {
 inputs 2
 fromInput1 {{0} B A}
 fromInput2 {{1} B A}
 in2 rgba
 out2 rgba
 mappings "8 rgba.red 0 0 rgba.alpha 0 3 rgba.blue 1 2 rgba.blue 1 2 black -1 -1 rgba.green 0 1 black -1 -1 rgba.red 0 0 black -1 -1 rgba.blue 0 2 rgba.red 1 0 rgba.red 1 0 rgba.green 1 1 rgba.green 1 1 black -1 -1 rgba.alpha 1 3"
 name Shuffle4
 xpos 139
 ypos 1
}
push $N8d998d0
Dot {
 name Dot1
 xpos -204
 ypos -74
}
CheckerBoard2 {
 inputs 0
 name CheckerBoard1
 xpos -443
 ypos -188
}
Reformat {
 format "2048 1024 0 0 2048 1024 1 2K_LatLong"
 name Reformat1
 xpos -443
 ypos -116
}
Dot {
 name Dot6
 xpos -409
 ypos 183
}
push $N8d587c0
Dot {
 name Dot2
 xpos -79
 ypos -63
}
Group {
 inputs 8
 name N_RayReflect
 knobChanged "\nnode = nuke.thisNode()\nknob = nuke.thisKnob()\nknob_value = knob.getValue()\n\nif knob.name() == \"use_diffuse_input\":\n    node.knob(\"diffuse_colour\").setEnabled(not knob_value)\nelif knob.name() == \"use_specular_input\":\n    node.knob(\"specular_colour\").setEnabled(not knob_value)\n    node.knob(\"specular\").setEnabled(not knob_value)\nelif knob.name() == \"use_transmission_input\":\n    node.knob(\"transmission_colour\").setEnabled(not knob_value)\n    node.knob(\"transmission\").setEnabled(not knob_value)\nelif knob.name() == \"use_specular_roughness_input\":\n    node.knob(\"specular_roughness\").setEnabled(not knob_value)\nelif knob.name() == \"use_transmission_roughness_input\":\n    node.knob(\"transmission_roughness\").setEnabled(not knob_value)\n"
 xpos -18
 ypos 179
 addUserKnob {20 User l "N Ray Reflect"}
 addUserKnob {41 in l Normals t "The channels that contain the normal data." T Shuffle1.in}
 addUserKnob {26 ""}
 addUserKnob {3 ray_samples l "Ray Samples" t "The number of ray samples. If you are not using roughness or diffuse surfaces, set this to 1."}
 ray_samples 1
 addUserKnob {7 hdri_offset l "HDRI Offset Angle" t "Rotate the HDRI by this angle." R 0 360}
 addUserKnob {26 ""}
 addUserKnob {20 material_properties l "Material Properties" n 1}
 addUserKnob {7 incident_refractive_index l "Incident Refractive Index" t "The index of refraction of the medium before refraction." R 1 3}
 incident_refractive_index 1
 addUserKnob {7 refracted_refractive_index l "Refracted Refractive Index" t "The index of refraction of the medium after refraction." R 1 3}
 refracted_refractive_index 1.33
 addUserKnob {26 ""}
 addUserKnob {18 diffuse_colour l "Diffuse Colour" +DISABLED}
 diffuse_colour 1
 addUserKnob {6 diffuse_colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 use_diffuse_input l "Use Input" -STARTLINE}
 use_diffuse_input true
 addUserKnob {26 ""}
 addUserKnob {18 specular_colour l "Specular Colour" +DISABLED}
 specular_colour 1
 addUserKnob {6 specular_colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 use_specular_input l "Use Input" -STARTLINE}
 use_specular_input true
 addUserKnob {7 specular l Specular +DISABLED}
 specular 0.5
 addUserKnob {7 specular_roughness l "Specular Roughness" +DISABLED}
 addUserKnob {6 use_specular_roughness_input l "Use Input" -STARTLINE}
 use_specular_roughness_input true
 addUserKnob {26 ""}
 addUserKnob {18 transmission_colour l "Transmission Colour" +DISABLED}
 transmission_colour 1
 addUserKnob {6 transmission_colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 use_transmission_input l "Use Input" -STARTLINE}
 use_transmission_input true
 addUserKnob {7 transmission l Transmission +DISABLED}
 addUserKnob {7 transmission_roughness l "Transmission Roughness" +DISABLED}
 addUserKnob {6 use_transmission_roughness_input l "Use Input" -STARTLINE}
 use_transmission_roughness_input true
 addUserKnob {20 endGroup_1 n -1}
 addUserKnob {26 ""}
 addUserKnob {20 irradiance_sampling l "Irradiance Sampling" n 1}
 addUserKnob {6 enable_precomputed_irradiance l "Enable Precomputed Irradiance" t "Use a precomputed irradiance for diffuse lighting. This will require only one sample rather than many in order to converge." +STARTLINE}
 enable_precomputed_irradiance true
 addUserKnob {3 irradiance_blur_size l "Irradiance Blur Size" t "Blur the HDRI by this amount before using it to compute the irradiance. This can help reduce artifacts caused by small, bright, light sources without increasing the 'Irradiance Samples'."}
 irradiance_blur_size 50
 addUserKnob {3 irradiance_samples l "Irradiance Samples" t "The number of samples in the horizontal direction that will be used to compute the irradiance of a hemisphere of the HDRI. Half this many samples will be used in the vertical direction."}
 irradiance_samples 200
 addUserKnob {6 output_irradiance l "Output Irradiance" t "Select this to view the irradiance." +STARTLINE}
 addUserKnob {20 endGroup n -1}
 addUserKnob {26 ""}
 addUserKnob {26 INFO l "" +STARTLINE T "v2.0.0 - (c) Owen Bulka and Riley Gray - 2022 "}
}
 Constant {
  inputs 0
  name Constant4
  xpos -1221
  ypos -186
 }
 Reformat {
  type "to box"
  box_width {{parent.normals_dot.width}}
  box_height {{parent.normals_dot.height}}
  box_fixed true
  name Reformat3
  xpos -1221
  ypos -114
 }
set N98993c0 [stack 0]
 Dot {
  name Dot2
  xpos -1096
  ypos -110
 }
 Dot {
  name Dot4
  xpos -1050
  ypos -110
 }
set N98ad570 [stack 0]
 Input {
  inputs 0
  name hdri
  xpos -1007
  ypos -167
  number 1
 }
 Merge2 {
  inputs 2
  bbox B
  name merge2
  xpos -1007
  ypos -70
 }
 Dot {
  name Dot9
  xpos -973
  ypos -27
 }
set N98c7890 [stack 0]
 Blur {
  size {{parent.irradiance_blur_size}}
  name Blur1
  xpos -906
  ypos -37
 }
 Reformat {
  type scale
  name Reformat1
  xpos -906
  ypos 1
 }
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/normal_ray_reflect/src/blink/kernels/hdri_irradiance.cpp
  recompileCount 5
  KernelDescription "2 \"HDRIrradiance\" iterate pixelWise c1af50c915b3e6678876693b985cdf385beceffe7ba4cc1363483e5c9937d3fa 2 \"hdri\" Read Random \"dst\" Write Point 1 \"Samples\" Int 2 ZAAAADIAAAA= 1 \"_samples\" 2 1 3 \"__hdriPixelSize\" Float 2 1 AAAAAAAAAAA= \"__up\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"__sampleStep\" Float 2 1 AAAAAAAAAAA="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n/**\n * Get the equivalent theta and phi values that lie between \[0, 2 * PI),\n * and \[0, PI) respectively.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent theta and phi.\n */\ninline float2 normalizeAngles(const float2 &angles)\n\{\n    float2 normalizedAngles = float2(\n        fmod(angles.x, 2.0f * PI),\n        fmod(angles.y, PI)\n    );\n    normalizedAngles.x += 2 * PI * (normalizedAngles.x < 0);\n    normalizedAngles.y += PI * (normalizedAngles.y < 0);\n\n    return normalizedAngles;\n\}\n\n\n/**\n * Convert a cartesion unit vector to spherical.\n *\n * @arg rayDirection: The cartesion unit vector.\n *\n * @returns: The spherical angles in radians.\n */\ninline float2 cartesionUnitVectorToSpherical(const float3 &rayDirection)\n\{\n    return normalizeAngles(float2(\n        atan2(rayDirection.z, rayDirection.x),\n        acos(rayDirection.y)\n    ));\n\}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n\{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n\}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n\{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n\}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n\{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n\}\n\n\nkernel HDRIrradiance : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessRandom, eEdgeClamped> hdri; // the input image\n    Image<eWrite> dst; // the output image\n\n    param:\n        int2 _samples;\n\n    local:\n        float2 __hdriPixelSize;\n        float3 __up;\n        float2 __sampleStep;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_samples, \"Samples\", int2(100, 50));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __hdriPixelSize = float2(hdri.bounds.width() / (2.0f * PI), hdri.bounds.height() / PI);\n        __up = float3(0, 1, 0);\n\n        __sampleStep = float2(\n            2.0f * PI / (float) _samples.x,\n            PI / (2.0f * (float) _samples.y)\n        );\n    \}\n\n\n    /**\n     * Get the value of hdri the ray would hit at infinite distance\n     *\n     * @arg rayDirection: The direction of the ray.\n     *\n     * @returns: The colour of the pixel in the direction of the ray.\n     */\n    float4 readHDRIValue(float3 rayDirection)\n    \{\n        const float2 angles = cartesionUnitVectorToSpherical(rayDirection);\n\n        // Why does bilinear give nans? :(\n        return hdri(\n            round(__hdriPixelSize.x * angles.x) - 1,\n            round(hdri.bounds.height() - (__hdriPixelSize.y * angles.y)) - 1\n        );\n    \}\n\n\n    /**\n     * Compute the irradiance of a pixel.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        const float2 uvPosition = pixelsToUV(\n            float2(pos.x, pos.y),\n            float2(hdri.bounds.width(), hdri.bounds.height())\n        );\n        const float3 direction = sphericalUnitVectorToCartesion(\n            uvPositionToAngles(uvPosition)\n        );\n\n        const float3 tangentRight = normalize(cross(__up, direction));\n        const float3 tangentUp = normalize(cross(direction, tangentRight));\n\n        float4 irradiance = float4(0);\n\n        for (float theta = 0.0f; theta < 2.0f * PI; theta += __sampleStep.x)\n        \{\n            for (float phi = PI / 2.0f; phi > 0.0f; phi -= __sampleStep.y)\n            \{\n                const float3 tangent = sphericalUnitVectorToCartesion(float2(theta, phi));\n                const float3 sampleDirection = (\n                    tangent.x * tangentRight\n                    + tangent.z * tangentUp\n                    + tangent.y * direction\n                );\n\n                irradiance += readHDRIValue(sampleDirection) * cos(phi) * sin(phi);\n            \}\n        \}\n\n        dst() = PI * irradiance / (float) (_samples.x * _samples.y);\n    \}\n\};\n"
  rebuild ""
  HDRIrradiance_Samples {{parent.irradiance_samples} {parent.irradiance_samples/2}}
  rebuild_finalise ""
  name BlinkScript2
  xpos -906
  ypos 27
 }
 Dot {
  name Dot11
  xpos -872
  ypos 244
 }
set N98f2ae0 [stack 0]
 Dot {
  name Dot10
  xpos -872
  ypos 588
 }
push $N98ad570
 Dot {
  name Dot17
  xpos -761
  ypos -110
 }
set N990a310 [stack 0]
 Dot {
  name Dot16
  xpos -516
  ypos -110
 }
set N990f150 [stack 0]
 Dot {
  name Dot19
  xpos -272
  ypos -110
 }
set N9914050 [stack 0]
 Dot {
  name Dot12
  xpos 15
  ypos -110
 }
set N9918f50 [stack 0]
 Dot {
  name Dot14
  xpos 239
  ypos -110
 }
set N991de50 [stack 0]
 Dot {
  name Dot3
  xpos 407
  ypos -110
 }
 Input {
  inputs 0
  name normals
  xpos 480
  ypos -162
 }
 Merge2 {
  inputs 2
  name merge1
  xpos 480
  ypos -75
 }
 Shuffle {
  in normals
  name Shuffle1
  xpos 480
  ypos -49
 }
 Dot {
  name normals_dot
  xpos 514
  ypos 301
 }
set N994dca0 [stack 0]
 Dot {
  name Dot5
  xpos 624
  ypos 301
 }
 Dot {
  name Dot7
  xpos 624
  ypos 494
 }
push $N98f2ae0
push $N98c7890
 Dot {
  name Dot1
  xpos -973
  ypos 280
 }
push $N9918f50
 Input {
  inputs 0
  name specRoughness
  xpos 49
  ypos -169
  number 6
 }
 Merge2 {
  inputs 2
  bbox B
  name merge5
  xpos 49
  ypos -71
 }
 Shuffle {
  green black
  blue black
  alpha black
  name Shuffle2
  xpos 49
  ypos -45
 }
 Constant {
  inputs 0
  color {{parent.specular_roughness} 0 0 0}
  name Constant5
  xpos -68
  ypos -22
 }
 Switch {
  inputs 2
  which {{parent.use_specular_roughness_input}}
  name Switch5
  xpos 49
  ypos 1
 }
 Dot {
  name Dot13
  xpos 83
  ypos 167
 }
push $N991de50
 Input {
  inputs 0
  name transRoughness
  xpos 279
  ypos -168
  number 7
 }
 Merge2 {
  inputs 2
  bbox B
  name merge6
  xpos 279
  ypos -72
 }
 Shuffle {
  red black
  blue black
  alpha black
  name Shuffle3
  xpos 279
  ypos -46
 }
 Constant {
  inputs 0
  color {0 {parent.transmission_roughness} 0 0}
  name Constant6
  xpos 162
  ypos -23
 }
 Switch {
  inputs 2
  which {{parent.use_transmission_roughness_input}}
  name Switch6
  xpos 279
 }
 Merge2 {
  inputs 2
  bbox B
  name merge7
  selected true
  xpos 279
  ypos 163
 }
 Dot {
  name Dot15
  xpos 313
  ypos 268
 }
push $N9914050
 Input {
  inputs 0
  name transmission
  xpos -184
  ypos -170
  number 5
 }
 Merge2 {
  inputs 2
  bbox B
  name merge4
  xpos -184
  ypos -71
 }
 Constant {
  inputs 0
  color {{parent.transmission_colour} {parent.transmission_colour} {parent.transmission_colour} {"min(1.0, max(0.0, parent.transmission))"}}
  name Constant3
  xpos -309
  ypos -19
 }
 Switch {
  inputs 2
  which {{parent.use_transmission_input}}
  name Switch4
  xpos -184
  ypos 4
 }
 Dot {
  name Dot20
  xpos -150
  ypos 203
 }
push $N990f150
 Input {
  inputs 0
  name specular
  xpos -423
  ypos -169
  number 3
 }
 Merge2 {
  inputs 2
  bbox B
  name merge
  xpos -423
  ypos -69
 }
 Constant {
  inputs 0
  color {{parent.specular_colour} {parent.specular_colour} {parent.specular_colour} {"min(1.0, max(0.0, parent.specular))"}}
  name Constant2
  xpos -546
  ypos -17
 }
 Switch {
  inputs 2
  which {{parent.use_specular_input}}
  name Switch3
  xpos -423
  ypos 6
 }
 Dot {
  name Dot6
  xpos -389
  ypos 226
 }
push $N990a310
 Input {
  inputs 0
  name diffuse
  xpos -670
  ypos -168
  number 4
 }
 Merge2 {
  inputs 2
  bbox B
  name merge3
  xpos -670
  ypos -69
 }
 Constant {
  inputs 0
  color {{parent.diffuse_colour} {parent.diffuse_colour} {parent.diffuse_colour} 1}
  name Constant1
  xpos -796
  ypos -17
 }
 Switch {
  inputs 2
  which {{parent.use_diffuse_input}}
  name Switch2
  xpos -670
  ypos 6
 }
 Dot {
  name Dot18
  xpos -636
  ypos 233
 }
push $N98993c0
 Noise {
  output {rgba.red -rgba.green -rgba.blue -rgba.alpha}
  size 1
  zoffset 2.1
  center {1024 778}
  name Noise4
  xpos -1221
  ypos -30
 }
 Noise {
  output {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  size 1
  zoffset 0.92
  lacunarity 4.2
  gain 0.685
  center {1024 778}
  name Noise3
  xpos -1221
  ypos -4
 }
 Noise {
  output {-rgba.red -rgba.green rgba.blue -rgba.alpha}
  size 1
  zoffset 4.04
  lacunarity 3.28
  gain 0.328
  center {1024 778}
  name Noise2
  xpos -1221
  ypos 22
 }
 Noise {
  output {-rgba.red -rgba.green -rgba.blue rgba.alpha}
  size 1
  zoffset 4.74
  lacunarity 1.59
  center {1024 778}
  name Noise1
  xpos -1221
  ypos 48
 }
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/normal_ray_reflect/src/blink/kernels/random.cpp
  recompileCount 2
  KernelDescription "2 \"Random\" iterate pixelWise 8e779966f94c894fa6f109f51d3914f34c4f7ba1db7b9984184abc7f04f54c4a 2 \"seed\" Read Point \"dst\" Write Point 1 \"Inclusive Range\" Float 2 AAAAAAAAgD8= 1 \"_inclusiveRange\" 2 1 1 \"__rangeLength\" Float 1 1 AAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(seed * 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float4 random(const float4 &seed)\n\{\n    return float4(\n        random(seed.x),\n        random(seed.y),\n        random(seed.z),\n        random(seed.w)\n    );\n\}\n\n\nkernel Random : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeNone> seed; // the input image\n    Image<eWrite> dst; // the output image\n\n\n    param:\n        float2 _inclusiveRange;\n\n    local:\n        float __rangeLength;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_inclusiveRange, \"Inclusive Range\", float2(0, 1));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __rangeLength = _inclusiveRange.y - _inclusiveRange.x;\n    \}\n\n\n    /**\n     * Compute a random pixel value.\n     */\n    void process()\n    \{\n        dst() = __rangeLength * random(seed()) + _inclusiveRange.x;\n    \}\n\};\n"
  rebuild ""
  rebuild_finalise ""
  name BlinkScript1
  xpos -1221
  ypos 93
 }
 Dot {
  name Dot8
  xpos -1187
  ypos 402
 }
push $N994dca0
 BlinkScript {
  inputs 8
  kernelSourceFile /home/ob1/software/nuke/dev/normal_ray_reflect/src/blink/kernels/normal_ray_reflect.cpp
  recompileCount 147
  ProgramGroup 1
  KernelDescription "2 \"NormalReflectionKernel\" iterate pixelWise 09303b3f57681105956e111f2b985efbec0fbcf83a0e8c1d7afcb396d392ae2f 9 \"normals\" Read Point \"seeds\" Read Point \"diffuse\" Read Point \"specular\" Read Point \"transmission\" Read Point \"material\" Read Point \"hdri\" Read Random \"irradiance\" Read Random \"dst\" Write Point 12 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"HDRI Offset Angle\" Float 1 AAAAAA== \"Use Precomputed Irradiance\" Bool 1 AQ== \"Samples\" Int 1 AQAAAA== \"Incident Refractive Index\" Float 1 AACAPw== \"Refracted Refractive Index\" Float 1 cT2qPw== 12 \"_focalLength\" 1 1 \"_horizontalAperture\" 1 1 \"_nearPlane\" 1 1 \"_farPlane\" 1 1 \"_cameraWorldMatrix\" 16 1 \"_formatWidth\" 1 1 \"_formatHeight\" 1 1 \"_hdriOffsetAngle\" 1 1 \"_usePrecomputedIrradiance\" 1 1 \"_samples\" 1 1 \"_incidentRefractiveIndex\" 1 1 \"_refractedRefractiveIndex\" 1 1 5 \"__inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__aperture\" Float 1 1 AAAAAA== \"__hdriPixelSize\" Float 2 1 AAAAAAAAAAA= \"__hdriOffsetRadians\" Float 1 1 AAAAAA== \"__irradiancePixelSize\" Float 2 1 AAAAAAAAAAA="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n//\n// BlinkScript Normal Reflections\n//\n\n\n//\n// Math\n//\n\n\n/**\n * Blend linearly between two values.\n *\n * @arg value0: The first value.\n * @arg value1: The second value.\n * @arg weight: The blend weight, 1 will return value0, and 0 will\n *     return value1.\n *\n * @returns: The blended value.\n */\ninline float blend(const float value0, const float value1, const float weight)\n\{\n    return value1 + weight * (value0 - value1);\n\}\n\n\n/**\n * Blend linearly between two values.\n *\n * @arg value0: The first value.\n * @arg value1: The second value.\n * @arg weight: The blend weight, 1 will return value0, and 0 will\n *     return value1.\n *\n * @returns: The blended value.\n */\ninline float3 blend(const float3 &value0, const float3 &value1, const float weight)\n\{\n    return value1 + weight * (value0 - value1);\n\}\n\n\n/**\n * Get the equivalent theta and phi values that lie between \[0, 2 * PI),\n * and \[0, PI) respectively.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent theta and phi.\n */\ninline float2 normalizeAngles(const float2 &angles)\n\{\n    float2 normalizedAngles = float2(\n        fmod(angles.x, 2.0f * PI),\n        fmod(angles.y, PI)\n    );\n    normalizedAngles.x += 2 * PI * (normalizedAngles.x < 0);\n    normalizedAngles.y += PI * (normalizedAngles.y < 0);\n\n    return normalizedAngles;\n\}\n\n\n/**\n * Convert a cartesion unit vector to spherical.\n *\n * @arg rayDirection: The cartesion unit vector.\n * @arg thetaOffset: Offset the theta angle by this amount.\n *\n * @returns: The spherical angles in radians.\n */\ninline float2 cartesionUnitVectorToSpherical(\n        const float3 &rayDirection,\n        const float thetaOffset)\n\{\n    return normalizeAngles(float2(\n        atan2(rayDirection.z, rayDirection.x) + thetaOffset,\n        acos(rayDirection.y)\n    ));\n\}\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n\{\n    position = float3(\n        worldMatrix\[0]\[3],\n        worldMatrix\[1]\[3],\n        worldMatrix\[2]\[3]\n    );\n\}\n\n\n/**\n * Saturate a value ie. clamp between 0 and 1\n *\n * @arg value: The value to saturate\n *\n * @returns: The clamped value\n */\ninline float saturate(float value)\n\{\n    return clamp(value, 0.0f, 1.0f);\n\}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n\{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n\}\n\n\n/**\n * Compute the aspect ratio from image format.\n *\n * @arg height_: The height of the image.\n * @arg width_: The width of the image.\n *\n * @returns: The aspect ratio.\n */\ninline float aspectRatio(const float height_, const float width_)\n\{\n    return height_ / width_;\n\}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n\{\n    return float3(\n        m\[0]\[0] * v.x + m\[0]\[1] * v.y + m\[0]\[2] * v.z,\n        m\[1]\[0] * v.x + m\[1]\[1] * v.y + m\[1]\[2] * v.z,\n        m\[2]\[0] * v.x + m\[2]\[1] * v.y + m\[2]\[2] * v.z\n    );\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n\{\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n\{\n    float4 out;\n    matmul(m, v, out);\n    return out;\n\}\n\n\n/**\n * Convert degrees to radians.\n *\n * @arg angle: The angle in degrees.\n *\n * @returns: The angle in radians.\n */\ninline float degreesToRadians(const float angle)\n\{\n    return angle * PI / 180.0f;\n\}\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * The positive part of the vector. Ie. any negative values will be 0.\n *\n * @arg vector: The vector.\n *\n * @returns: The positive part of the vector.\n */\ninline float positivePart(const float value)\n\{\n    return max(value, 0.0f);\n\}\n\n\n/**\n * Get a rotation matrix from an axis and an angle about that axis.\n *\n * @arg angles: The rotation angles in radians.\n * @arg out: The location to store the rotation matrix.\n */\ninline void axisAngleRotationMatrix(const float3 &axis, const float angle, float3x3 &out)\n\{\n    const float cosAngle = cos(angle);\n    const float oneMinusCosAngle = 1.0f - cosAngle;\n    const float sinAngle = sin(angle);\n\n    const float3 axisSquared = axis * axis;\n\n    const float axisXY = axis.x * axis.y * oneMinusCosAngle;\n    const float axisXZ = axis.x * axis.z * oneMinusCosAngle;\n    const float axisYZ = axis.y * axis.z * oneMinusCosAngle;\n\n    const float3 axisSinAngle = axis * sinAngle;\n\n    out\[0]\[0] = cosAngle + axisSquared.x * oneMinusCosAngle;\n    out\[0]\[1] = axisXY - axisSinAngle.z;\n    out\[0]\[2] = axisXZ + axisSinAngle.y;\n    out\[1]\[0] = axisXY + axisSinAngle.z;\n    out\[1]\[1] = cosAngle + axisSquared.y * oneMinusCosAngle;\n    out\[1]\[2] = axisYZ - axisSinAngle.x;\n    out\[2]\[0] = axisXZ - axisSinAngle.y;\n    out\[2]\[1] = axisYZ + axisSinAngle.x;\n    out\[2]\[2] = cosAngle + axisSquared.z * oneMinusCosAngle;\n\}\n\n\n/**\n * Get the angle and axis to use to rotate a vector onto another.\n *\n * @arg axis: The rotation angles in radians.\n * @arg out: The location to store the axis.\n *\n * @returns: The angle.\n */\ninline float getAngleAndAxisBetweenVectors(\n        const float3 &vector0,\n        const float3 &vector1,\n        float3 &axis)\n\{\n    const float3 perpendicularVector = cross(vector0, vector1);\n    if (length(perpendicularVector) > 0.0f)\n    \{\n        axis = normalize(perpendicularVector);\n    \}\n    else if (vector1.z != 0.0f || vector1.y != 0.0f)\n    \{\n        axis = normalize(cross(float3(1, 0, 0), vector1));\n    \}\n    else if (vector1.x != 0.0f || vector1.z != 0.0f)\n    \{\n        axis = normalize(cross(float3(0, 1, 0), vector1));\n    \}\n    else if (vector1.x != 0.0f || vector1.y != 0.0f)\n    \{\n        axis = normalize(cross(float3(0, 0, 1), vector1));\n    \}\n    else\n    \{\n        axis = vector0;\n    \}\n    return acos(dot(vector0, vector1));\n\}\n\n\n/**\n * Align a vector that has been defined relative to an axis with another\n * axis. For example if a vector has been chosen randomly in a\n * particular hemisphere, rotate that hemisphere to align with a new\n * axis.\n *\n * @arg unalignedAxis: The axis, about which, the vector was defined.\n * @arg alignDirection: The axis to align with.\n * @arg vectorToAlign: The vector that was defined relative to\n *     unalignedAxis.\n *\n * @returns: \n */\ninline float3 alignWithDirection(\n        const float3 &unalignedAxis,\n        const float3 &alignDirection,\n        const float3 &vectorToAlign)\n\{\n    float3 rotationAxis;\n    const float angle = getAngleAndAxisBetweenVectors(\n        unalignedAxis,\n        alignDirection,\n        rotationAxis\n    );\n\n    if (angle == 0.0f)\n    \{\n        return vectorToAlign;\n    \}\n\n    float3x3 rotationMatrix;\n    axisAngleRotationMatrix(rotationAxis, angle, rotationMatrix);\n\n    return matmul(rotationMatrix, vectorToAlign);\n\}\n\n\n//\n// Random\n//\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(seed * 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float2 random(const float2 &seed)\n\{\n    return float2(\n        random(seed.x),\n        random(seed.y)\n    );\n\}\n\n\n/**\n * Create a random unit vector in the hemisphere aligned along the\n * z-axis, with a distribution that is cosine weighted.\n *\n * @arg seed: The random seed.\n *\n * @returns: A random unit vector.\n */\nfloat3 cosineDirectionInZHemisphere(const float2 &seed)\n\{\n    const float uniform = random(seed.x);\n    const float r = sqrt(uniform);\n    const float angle = 2 * PI * random(seed.y);\n \n    const float x = r * cos(angle);\n    const float y = r * sin(angle);\n \n    return float3(x, y, sqrt(positivePart(1 - uniform)));\n\}\n\n\n/**\n * Create a random unit vector in the hemisphere aligned along the\n * given axis, with a distribution that is cosine weighted.\n *\n * @arg axis: The axis to align the hemisphere with.\n * @arg seed: The random seed.\n *\n * @returns: A random unit vector.\n */\nfloat3 cosineDirectionInHemisphere(const float3 &axis, const float2 &seed)\n\{\n    return normalize(alignWithDirection(\n        float3(0, 0, 1),\n        axis,\n        cosineDirectionInZHemisphere(seed)\n    ));\n\}\n\n\n//\n// Camera\n//\n\n\n/**\n * Create a projection matrix for a camera.\n *\n * @arg focalLength: The focal length of the camera.\n * @arg horizontalAperture: The horizontal aperture of the camera.\n * @arg aspect: The aspect ratio of the camera.\n * @arg nearPlane: The distance to the near plane of the camera.\n * @arg farPlane: The distance to the far plane of the camera.\n *\n * @returns: The camera's projection matrix.\n */\nfloat4x4 projectionMatrix(\n        const float focalLength,\n        const float horizontalAperture,\n        const float aspect,\n        const float nearPlane,\n        const float farPlane)\n\{\n    float farMinusNear = farPlane - nearPlane;\n    return float4x4(\n        2 * focalLength / horizontalAperture, 0, 0, 0,\n        0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n        0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n        0, 0, -1, 0\n    );\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    float4 direction = matmul(\n        inverseProjectionMatrix,\n        float4(uvPosition.x, uvPosition.y, 0, 1)\n    );\n    matmul(\n        cameraWorldMatrix,\n        float4(direction.x, direction.y, direction.z, 0),\n        direction\n    );\n    rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n\}\n\n\n//\n// Surface Interaction\n//\n\n\n/**\n * Reflect a ray off of a surface.\n *\n * @arg incidentRayDirection: The incident direction.\n * @arg surfaceNormalDirection: The normal to the surface.\n */\ninline float3 reflectRayOffSurface(\n        const float3 &incidentRayDirection,\n        const float3 &surfaceNormalDirection)\n\{\n    return normalize(\n        incidentRayDirection\n        - 2 * dot(incidentRayDirection, surfaceNormalDirection) * surfaceNormalDirection\n    );\n\}\n\n\n/**\n * Refract a ray through a surface.\n *\n * @arg incidentRayDirection: The incident direction.\n * @arg surfaceNormalDirection: The normal to the surface.\n * @arg incidentRefractiveIndex: The refractive index the incident ray\n *     is travelling through.\n * @arg refractedRefractiveIndex: The refractive index the refracted ray\n *     will be travelling through.\n *\n * @returns: The refracted ray direction.\n */\ninline float3 refractRayThroughSurface(\n        const float3 &incidentRayDirection,\n        const float3 &surfaceNormalDirection,\n        const float incidentRefractiveIndex,\n        const float refractedRefractiveIndex)\n\{\n    const float refractiveRatio = incidentRefractiveIndex / refractedRefractiveIndex;\n    const float cosIncident = -dot(incidentRayDirection, surfaceNormalDirection);\n    const float sinTransmittedSquared = refractiveRatio * refractiveRatio * (\n        1.0f - cosIncident * cosIncident\n    );\n    if (sinTransmittedSquared > 1.0f)\n    \{\n        return reflectRayOffSurface(incidentRayDirection, surfaceNormalDirection);\n    \}\n    const float cosTransmitted = sqrt(1.0f - sinTransmittedSquared);\n    return normalize(\n        refractiveRatio * incidentRayDirection\n        + (refractiveRatio * cosIncident - cosTransmitted) * surfaceNormalDirection\n    );\n\}\n\n\n/**\n * Compute the schlick, simplified fresnel reflection coefficient.\n *\n * @arg incidentRayDirection: The incident direction.\n * @arg surfaceNormalDirection: The normal to the surface.\n * @arg incidentRefractiveIndex: The refractive index the incident ray\n *     is travelling through.\n * @arg refractedRefractiveIndex: The refractive index the refracted ray\n *     will be travelling through.\n *\n * @returns: The reflection coefficient.\n */\nfloat schlickReflectionCoefficient(\n        const float3 &incidentRayDirection,\n        const float3 &surfaceNormalDirection,\n        const float incidentRefractiveIndex,\n        const float refractedRefractiveIndex)\n\{\n    const float parallelCoefficient = pow(\n        (incidentRefractiveIndex - refractedRefractiveIndex)\n        / (incidentRefractiveIndex + refractedRefractiveIndex),\n        2\n    );\n    float cosX = -dot(surfaceNormalDirection, incidentRayDirection);\n    if (incidentRefractiveIndex > refractedRefractiveIndex)\n    \{\n        const float refractiveRatio = incidentRefractiveIndex / refractedRefractiveIndex;\n        const float sinTransmittedSquared = refractiveRatio * refractiveRatio * (\n            1.0f - cosX * cosX\n        );\n        if (sinTransmittedSquared > 1.0f)\n        \{\n            return 1.0f;\n        \}\n        cosX = sqrt(1.0f - sinTransmittedSquared);\n    \}\n    return parallelCoefficient + (1.0f - parallelCoefficient) * pow(1.0f - cosX, 5);\n\}\n\n\nkernel NormalReflectionKernel : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeClamped> normals;\n    Image<eRead, eAccessPoint, eEdgeClamped> seeds;\n    Image<eRead, eAccessPoint, eEdgeClamped> diffuse;\n    Image<eRead, eAccessPoint, eEdgeClamped> specular;\n    Image<eRead, eAccessPoint, eEdgeClamped> transmission;\n    Image<eRead, eAccessPoint, eEdgeClamped> material;\n\n    Image<eRead, eAccessRandom, eEdgeClamped> hdri;\n    Image<eRead, eAccessRandom, eEdgeClamped> irradiance;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float _focalLength;\n        float _horizontalAperture;\n        float _nearPlane;\n        float _farPlane;\n        float4x4 _cameraWorldMatrix;\n\n        // Image params\n        float _formatWidth;\n        float _formatHeight;\n\n        float _hdriOffsetAngle;\n        bool _usePrecomputedIrradiance;\n\n        // Ray Params\n        int _samples;\n\n        float _incidentRefractiveIndex;\n        float _refractedRefractiveIndex;\n\n\n    local:\n        // These local variables are not exposed to the user.\n\n        float4x4 __inverseCameraProjectionMatrix;\n        float __aperture;\n\n        float2 __hdriPixelSize;\n        float __hdriOffsetRadians;\n        float2 __irradiancePixelSize;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        // Camera params\n        defineParam(_focalLength, \"Focal Length\", 50.0f);\n        defineParam(_horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(_nearPlane, \"Near Plane\", 0.1f);\n        defineParam(_farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            _cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n\n        // Image params\n        defineParam(_formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(_formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(_hdriOffsetAngle, \"HDRI Offset Angle\", 0.0f);\n        defineParam(_usePrecomputedIrradiance, \"Use Precomputed Irradiance\", true);\n\n        // Ray Params\n        defineParam(_samples, \"Samples\", 1);\n        defineParam(_incidentRefractiveIndex, \"Incident Refractive Index\", 1.0f);\n        defineParam(_refractedRefractiveIndex, \"Refracted Refractive Index\", 1.33f);\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        float aspect = aspectRatio(_formatHeight, _formatWidth);\n        float4x4 cameraProjectionMatrix = projectionMatrix(\n            _focalLength,\n            _horizontalAperture,\n            aspect,\n            _nearPlane,\n            _farPlane\n        );\n        __inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();\n\n        __hdriPixelSize = float2(\n            hdri.bounds.width() / (2 * PI),\n            hdri.bounds.height() / PI\n        );\n        __irradiancePixelSize = float2(\n            irradiance.bounds.width() / (2 * PI),\n            irradiance.bounds.height() / PI\n        );\n        __hdriOffsetRadians = degreesToRadians(_hdriOffsetAngle);\n    \}\n\n\n    /**\n     * Get the value of hdri the ray would hit at infinite distance\n     *\n     * @arg rayDirection: The direction of the ray.\n     *\n     * @returns: The colour of the pixel in the direction of the ray.\n     */\n    float4 readHDRIValue(float3 rayDirection)\n    \{\n        const float2 angles = cartesionUnitVectorToSpherical(rayDirection, __hdriOffsetRadians);\n\n        // Should be able to say image access is eEdgeClamped and not do this\n        // but I see nan pixels sooo... :(\n        const float2 indices = clamp(\n            float2(\n                __hdriPixelSize.x * angles.x,\n                hdri.bounds.height() - (__hdriPixelSize.y * angles.y)\n            ),\n            float2(0),\n            float2(hdri.bounds.width(), hdri.bounds.height()) - 1.0f\n        );\n\n        return bilinear(hdri, indices.x, indices.y);\n    \}\n\n\n    /**\n     * Get the value of irradiance the hdri would provide in a direction\n     *\n     * @arg rayDirection: The direction of the ray.\n     *\n     * @returns: The colour of the pixel in the direction of the ray.\n     */\n    inline float4 readIrradianceValue(float3 rayDirection)\n    \{\n        const float2 angles = cartesionUnitVectorToSpherical(rayDirection, __hdriOffsetRadians);\n\n        // Should be able to say image access is eEdgeClamped and not do this\n        // but I see nan pixels sooo... :(\n        const float2 indices = clamp(\n            float2(\n                __irradiancePixelSize.x * angles.x,\n                irradiance.bounds.height() - (__irradiancePixelSize.y * angles.y)\n            ),\n            float2(0),\n            float2(irradiance.bounds.width(), irradiance.bounds.height()) - 1.0f\n        );\n\n        return bilinear(irradiance, indices.x, indices.y);\n    \}\n\n\n    /**\n     * Create a ray out of the camera\n     *\n     * @arg pixelLocation: The x, and y locations of the pixel.\n     * @arg rayOrigin: The location to store the origin of the new ray.\n     * @arg rayDirection: The location to store the direction of the new\n     *     ray.\n     */\n    void getCameraRay(\n            const float2 &seed,\n            const float2 &pixelLocation,\n            float3 &rayOrigin,\n            float3 &rayDirection)\n    \{\n        const float2 uvCoordinates = pixelsToUV(\n            pixelLocation + random(seed),\n            float2(_formatWidth, _formatHeight)\n        );\n\n        createCameraRay(\n            _cameraWorldMatrix,\n            __inverseCameraProjectionMatrix,\n            uvCoordinates,\n            rayOrigin,\n            rayDirection\n        );\n    \}\n\n\n    /**\n     * Compute a raymarched pixel value.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        const float2 pixelLocation = float2(pos.x, pos.y);\n\n        SampleType(seeds) seed4 = seeds();\n        float2 seed0 = float2(seed4.x, seed4.y);\n        float2 seed1 = float2(seed4.z, seed4.w);\n\n        SampleType(normals) normal = normals();\n        const float3 normalDirection = float3(\n            normal.x,\n            normal.y,\n            normal.z\n        );\n\n        const float4 diffuseColour = diffuse();\n        const float4 specularColour = specular();\n        const float4 transmissionColour = transmission();\n        const float4 materialProperties = material();\n\n        const float specular = saturate(specularColour.w);\n        float transmission;\n        if (specular + transmissionColour.w > 1.0f)\n        \{\n            transmission = 1.0f - specular;\n        \}\n        else\n        \{\n            transmission = saturate(transmissionColour.w);\n        \}\n        const float diffuse = saturate(1.0f - transmission - specular);\n\n        const float specularRoughness = materialProperties.x * materialProperties.x;\n        const float transmissionRoughness = materialProperties.y * materialProperties.y;\n        // TODO: use material properties z and w slots to represent something, maybe anisotropy\n\n        float4 resultPixel = float4(0);\n\n        for (int sample=1; sample <= _samples; sample++)\n        \{\n            // Generate a ray from the camera\n            float3 rayOrigin;\n            float3 rayDirection;\n            getCameraRay(\n                seed0,\n                pixelLocation,\n                rayOrigin,\n                rayDirection\n            );\n\n            if (\n                normalDirection.x != 0.0f\n                || normalDirection.y != 0.0f\n                || normalDirection.z != 0.0f\n            ) \{\n                // Get the diffuse direction for the next ray\n                const float3 diffuseDirection = cosineDirectionInHemisphere(\n                    normalDirection,\n                    seed1\n                );\n\n                if (diffuse > 0.0f)\n                \{\n                    if (_usePrecomputedIrradiance)\n                    \{\n                        resultPixel += diffuse * diffuseColour * readIrradianceValue(normalDirection);\n                    \}\n                    else\n                    \{\n                        resultPixel += diffuse * diffuseColour * readHDRIValue(diffuseDirection);\n                    \}\n                \}\n                float fresnelSpecular = specular;\n                if (transmission > 0.0f || specular > 0.0f)\n                \{\n                    const float reflectivity = schlickReflectionCoefficient(\n                        rayDirection,\n                        normalDirection,\n                        _incidentRefractiveIndex,\n                        _refractedRefractiveIndex\n                    );\n\n                    fresnelSpecular = blend(1.0f, specular, reflectivity);\n\n                    if (transmission > 0.0f)\n                    \{\n                        resultPixel += (\n                            transmission * transmissionColour * (1.0f - fresnelSpecular)\n                            * readHDRIValue(normalize(blend(\n                                diffuseDirection,\n                                refractRayThroughSurface(\n                                    rayDirection,\n                                    normalDirection,\n                                    _incidentRefractiveIndex,\n                                    _refractedRefractiveIndex\n                                ),\n                                transmissionRoughness\n                            )))\n                            / (1.0f - specular)\n                        );\n                        \n                    \}\n                \}\n                if (fresnelSpecular > 0.0f)\n                \{\n                    resultPixel += (\n                        fresnelSpecular * specularColour\n                        * readHDRIValue(normalize(blend(\n                            diffuseDirection,\n                            reflectRayOffSurface(rayDirection, normalDirection),\n                            specularRoughness\n                        )))\n                    );\n                \}\n            \}\n            else\n            \{\n                resultPixel += readHDRIValue(rayDirection);\n            \}\n\n            // Update the seeds in as unbiased a way as we can think of\n            seed0 = random(seed1 + random(seed0));\n            float x = seed0.x;\n            seed0.x = seed0.y;\n            seed0.y = x;\n            seed1 = random(seed0 + random(seed1));\n            x = seed1.x;\n            seed1.x = seed1.y;\n            seed1.y = seed0.x;\n            seed0.x = x;\n        \}\n\n        dst() = resultPixel / (float) _samples;\n    \}\n\};\n"
  rebuild ""
  "NormalReflectionKernel_Focal Length" {{parent.DummyCam.focal}}
  "NormalReflectionKernel_Horizontal Aperture" {{parent.DummyCam.haperture}}
  "NormalReflectionKernel_Near Plane" {{parent.DummyCam.near}}
  "NormalReflectionKernel_Far Plane" {{parent.DummyCam.far}}
  "NormalReflectionKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
    }
  "NormalReflectionKernel_Screen Width" {{proxy?width*proxy_scale:width}}
  "NormalReflectionKernel_Screen Height" {{proxy?height*proxy_scale:height}}
  "NormalReflectionKernel_HDRI Offset Angle" {{parent.hdri_offset}}
  "NormalReflectionKernel_Use Precomputed Irradiance" {{parent.enable_precomputed_irradiance}}
  NormalReflectionKernel_Samples {{parent.ray_samples}}
  "NormalReflectionKernel_Incident Refractive Index" {{parent.incident_refractive_index}}
  "NormalReflectionKernel_Refracted Refractive Index" {{parent.refracted_refractive_index}}
  rebuild_finalise ""
  name BlinkScript3
  xpos 480
  ypos 392
 }
 Expression {
  expr0 isnan(r)?0:r
  expr1 isnan(g)?0:g
  expr2 isnan(b)?0:b
  expr3 isnan(a)?0:a
  name no_nans
  xpos 480
  ypos 430
 }
 CopyBBox {
  inputs 2
  name CopyBBox1
  xpos 480
  ypos 490
 }
 Switch {
  inputs 2
  which {{parent.output_irradiance}}
  name Switch1
  xpos 480
  ypos 584
 }
 Output {
  name Output1
  xpos 480
  ypos 653
 }
 Input {
  inputs 0
  name camera
  xpos 700
  ypos -161
  number 2
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos 710
  ypos -85
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
end_group
